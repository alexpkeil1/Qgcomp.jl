<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generalized Linear Models · Qgcomp: quantile g-computation in Julia</title><meta name="title" content="Generalized Linear Models · Qgcomp: quantile g-computation in Julia"/><meta property="og:title" content="Generalized Linear Models · Qgcomp: quantile g-computation in Julia"/><meta property="twitter:title" content="Generalized Linear Models · Qgcomp: quantile g-computation in Julia"/><meta name="description" content="Documentation for Qgcomp: quantile g-computation in Julia."/><meta property="og:description" content="Documentation for Qgcomp: quantile g-computation in Julia."/><meta property="twitter:description" content="Documentation for Qgcomp: quantile g-computation in Julia."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Qgcomp: quantile g-computation in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Help</a></li><li><span class="tocitem">Details</span><ul><li class="is-active"><a class="tocitem" href>Generalized Linear Models</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-the-Qgcomp-module"><span>How to use the <code>Qgcomp</code> module</span></a></li><li><a class="tocitem" href="#FAQ"><span>FAQ</span></a></li></ul></li><li><a class="tocitem" href="../math/underlying_math/">Underlying math</a></li></ul></li><li><span class="tocitem">Math</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Details</a></li><li class="is-active"><a href>Generalized Linear Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Generalized Linear Models</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-Qgcomp.jl"><a class="docs-heading-anchor" href="#Introduction-to-Qgcomp.jl">Introduction to Qgcomp.jl</a><a id="Introduction-to-Qgcomp.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Qgcomp.jl" title="Permalink"></a></h1><p>Note: this is (copied directly from the qgcomp package in R, basic vignette).</p><p><code>Qgcomp.jl</code> is a module to implement g-computation for analyzing the effects of exposure mixtures. Quantile g-computation yields estimates of the effect of increasing all exposures by one quantile, simultaneously. This, it estimates a &quot;mixture effect&quot; useful in the study of exposure mixtures such as air pollution, diet, and water contamination.</p><p>Using terminology from methods developed for causal effect estimation, quantile  g-computation estimates the parameters of a marginal structural model that  characterizes the change in the expected potential outcome given a joint intervention on all exposures, possibly conditional on confounders. Under the assumptions of exchangeability, causal consistency, positivity, no interference, and correct model specification, this model yields a causal effect for an intervention on the mixture as a whole. While these assumptions may not be met exactly, they provide a useful road map for how to interpret the results of a qgcomp fit, and where efforts should be spent in terms of ensuring accurate model specification and selection of exposures that are sufficient to control co-pollutant confounding.</p><h3 id="The-model"><a class="docs-heading-anchor" href="#The-model">The model</a><a id="The-model-1"></a><a class="docs-heading-anchor-permalink" href="#The-model" title="Permalink"></a></h3><p>Say we have an outcome <span>$Y$</span>, some exposures <span>$\mathbb{X}$</span> and possibly some other covariates (e.g. potential confounders) denoted by <span>$\mathbb{Z}$</span>.</p><p>The basic model of quantile g-computation is a joint marginal structural model given by</p><p class="math-container">\[\mathbb{E}(Y^{\mathbf{X}_q} | \mathbf{Z,\psi,\eta}) = g(\psi_0 + \psi_1 S_q +  \mathbf{\eta Z})\]</p><p>where <span>$g(\cdot)$</span> is a link function in a generalized linear model (e.g. the inverse logit function in the case of a logistic model for the probability that <span>$Y=1$</span>), <span>$\psi_0$</span> is the model intercept, <span>$\mathbf{\eta}$</span> is a set of model coefficients for the covariates and <span>$S_q$</span> is an &quot;index&quot; that represents a joint value of exposures. Quantile g-computation (by default) transforms all exposures <span>$\mathbf{X}$</span> into <span>$\mathbf{X}_q$</span>, which are &quot;scores&quot; taking on discrete values 0,1,2,etc. representing a categorical &quot;bin&quot; of exposure. By default, there are four bins with evenly spaced quantile cutpoints for each exposure, so <span>${X}_q=0$</span> means that <span>$X$</span> was below the observed 25th percentile for that exposure. The index <span>$S_q$</span> represents all exposures being set to the same value (again, by default, discrete values 0,1,2,3). Thus, <em>the parameter <span>$\psi_1$</span> quantifies the expected change in the outcome, given a one quantile increase in all exposures simultaneously,</em> possibly adjusted for <span>$\mathbf{Z}$</span>. </p><p>There are nuances to this particular model form that are available in the <code>qgcomp</code> package which will be explored below. There exists one special case of quantile g-computation that leads to fast fitting: linear/additive exposure effects. Here we simulate &quot;pre-quantized&quot; data where the exposures <span>$X_1, X_2, X_3$</span> can only take on values of 0,1,2,3 in equal proportions. The model underlying the outcomes is given by the linear regression:</p><p class="math-container">\[\mathbb{E}(Y | \mathbf{X,\beta}) = \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_3\]</p><p>with the true values of <span>$\beta_0=0, \beta_1 =0.25, \beta_2 =-0.1, \beta_3=0.05$</span>, and <span>$X_1$</span> is strongly positively correlated with <span>$X_2$</span> (<span>$\rho=0.95$</span>) and negatively correlated with <span>$X_3$</span> (<span>$\rho=-0.3$</span>). In this simple setting, the parameter <span>$\psi_1$</span> will equal the sum of the <span>$\beta$</span> coefficients (0.2). Here we see that qgcomp estimates a value very close to 0.2 (as we increase sample size, the estimated value will be expected to become increasingly close to 0.2).</p><pre><code class="language-julia hljs">#cd(&quot;Qgcomp.jl/docs/src/fig/&quot;)

using Qgcomp, DataFrames, Random, StatsBase, GLM, StatsModels

# a function to generate quantized data with a specific correlation structure
function genxq(rng, n, corr=(0.95, -0.3), q=4)
    x = rand(rng, n, length(corr)+1)
    props = abs.(corr)
    ns = floor.(Int, n .* props)
    nidx = [setdiff(1:n, sample(rng, 1:n, nsi, replace=false)) for nsi in ns]
    for (j,c) in enumerate(corr)
        x[:,j+1] .= x[:,1]
        x[nidx[j],j+1] .= sample(rng, x[nidx[j],1], length(nidx[j]), replace=false)
        if c &lt; 0
            x[:,j+1] .= 1.0 .- x[:,j+1]
        end
    end
    xq, _ = Qgcomp.get_xq(x, q)
    x, xq
end

# generate some data under a linear model with &quot;quantized&quot; exposures
    rng = Xoshiro(321)
    n = 1000
    X, Xq = genxq(rng, 1000, (0.95, -0.3))
    y = randn(rng, n) + Xq * [0.25, -0.1, 0.05]
    lindata = DataFrame(hcat(y, X), [:y, :x1, :x2, :x3])

    # check correlations
    println(cor(Xq))

    # fit model
    qgcomp_glm_noboot(@formula(y~x1+x2+x3), lindata, [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;], 4, Normal())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled effect size (negative direction)
<span class="sgr1">1×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure  coef       weight   ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String    Float64    Float64  Float64   </span>
─────┼─────────────────────────────────────────
   1 │ x2        -0.166811      1.0  -0.166811
Scaled effect size (positive direction)
<span class="sgr1">2×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure  coef       weight     ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String    Float64    Float64    Float64   </span>
─────┼───────────────────────────────────────────
   1 │ x3        0.0209875  0.0596686   0.351734
   2 │ x1        0.330746   0.940331    0.351734
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error     z  Pr(&gt;|z|)   Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  0.0292843   0.0784494  0.37    0.7089  -0.124474    0.183042
mixture      0.184923    0.0480701  3.85    0.0001   0.0907069   0.279138
─────────────────────────────────────────────────────────────────────────
</code></pre><h2 id="How-to-use-the-Qgcomp-module"><a class="docs-heading-anchor" href="#How-to-use-the-Qgcomp-module">How to use the <code>Qgcomp</code> module</a><a id="How-to-use-the-Qgcomp-module-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-the-Qgcomp-module" title="Permalink"></a></h2><p>Here we use a running example from the <code>metals</code> dataset (part of the <code>qgcomp</code> package in R) to demonstrate some features of the package and method. </p><p>Namely, the examples below demonstrate use of the package for:</p><ol><li>Fast estimation of exposure effects under a linear model for quantized exposures for continuous (normal) outcomes</li><li>Estimating conditional and marginal odds/risk ratios of a mixture effect for binary outcomes</li><li>Adjusting for non-exposure covariates when estimating effects of the mixture</li><li>Allowing non-linear and non-homogeneous effects of individual exposures and the mixture as a whole by including product terms</li><li>Using qgcomp to fit a time-to-event model to estimate conditional and marginal hazard ratios for the exposure mixture</li></ol><p>For analogous approaches to estimating exposure mixture effects, illustrative examples can be seen in the <code>gQWS</code> package help files, which implements weighted quantile sum (WQS) regression, and at https://jenfb.github.io/bkmr/overview.html, which describes Bayesian kernel machine regression.</p><p>The <code>metals</code> dataset from the package <code>qgcomp</code>, comprises a set of simulated well water exposures and two health outcomes (one continuous, one binary/time-to-event). The exposures are transformed to have mean = 0.0, standard deviation = 1.0. The data are used throughout to demonstrate usage and features of the <code>qgcomp</code> package.</p><pre><code class="language-julia hljs">using RData
tf = tempname() * &quot;.RData&quot;
download(&quot;https://github.com/alexpkeil1/qgcomp/raw/refs/heads/main/data/metals.RData&quot;, tf)
metals = load(tf)[&quot;metals&quot;]
println(metals[1:10,:])

# we save the names of the mixture variables in the variable &quot;Xnm&quot;
Xnm = [
    &quot;arsenic&quot;,&quot;barium&quot;,&quot;cadmium&quot;,&quot;calcium&quot;,&quot;chromium&quot;,&quot;copper&quot;,
    &quot;iron&quot;,&quot;lead&quot;,&quot;magnesium&quot;,&quot;manganese&quot;,&quot;mercury&quot;,&quot;selenium&quot;,&quot;silver&quot;,
    &quot;sodium&quot;,&quot;zinc&quot;

];

covars = [&quot;nitrate&quot;,&quot;nitrite&quot;,&quot;sulfate&quot;,&quot;ph&quot;, &quot;total_alkalinity&quot;,&quot;total_hardness&quot;];</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6-element Vector{String}:
 &quot;nitrate&quot;
 &quot;nitrite&quot;
 &quot;sulfate&quot;
 &quot;ph&quot;
 &quot;total_alkalinity&quot;
 &quot;total_hardness&quot;</code></pre><h3 id="Example-1:-linear-model"><a class="docs-heading-anchor" href="#Example-1:-linear-model">Example 1: linear model</a><a id="Example-1:-linear-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-linear-model" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Qgcomp.qgcomp_glm_noboot" href="#Qgcomp.qgcomp_glm_noboot"><code>Qgcomp.qgcomp_glm_noboot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">using Qgcomp, DataFrames, StatsModels

x1 = rand(100, 3)
x = rand(100, 3)
z = rand(100, 3)
xq, _ = Qgcomp.get_xq(x, 4)
y = randn(100) + xq * [.1, 0.05, 0]
data = DataFrame(hcat(y,x,z), [:y, :x1, :x2, :x3, :z1, :z2, :z3])
form = @formula(y~x1+x2+x3+z1+z2+z3)
form_noint = @formula(y~-1+x1+x2+x3+z1+z2+z3)
expnms = [:x1, :x2, :x3]

m = qgcomp_glm_noboot(form, data, expnms, 4, Normal())
m = qgcomp_glm_noboot(form_noint, data, expnms, 4, Normal())
fitted(m)
aic(m)
aicc(m)
bic(m)
loglikelihood(m)</code></pre></div></section></article><pre><code class="language-julia hljs"># Example 1: linear model
# Run the model and save the results &quot;qc_fit&quot;
f = @formula(y~1+a+b)
ff = FormulaTerm(f.lhs, (Term.(Symbol.(Xnm))...,))
qgcomp_glm_noboot(ff, metals[:,vcat(Xnm, &quot;y&quot;)], Xnm, 4, Normal()) # run once to compile
@time qc_fit = qgcomp_glm_noboot(ff, metals[:,vcat(Xnm, &quot;y&quot;)], Xnm, 4, Normal())

#  0.001750 seconds (49.98 k allocations: 2.679 MiB)
# contrasting other methods with computational speed
# WQS regression (v3.0.1 of gWQS package in R)
#system.time(wqs.fit = gWQS::gwqs(y~wqs,mix_name=Xnm, data=metals[:,vcat(Xnm, &quot;y&quot;)], Normal(), 4))
#   user  system elapsed
# 35.775   0.124  36.114

# Bayesian kernel machine regression (note that the number of iterations here would
#  need to be &gt;5,000, at minimum, so this underestimates the run time by a factor
#  of 50+
#system.time(bkmr.fit = kmbayes(y=metals$y, Z=metals[,Xnm], family=&quot;gaussian&quot;, iter=100))
#   user  system elapsed
# 81.644   4.194  86.520</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled effect size (negative direction)
<span class="sgr1">5×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure   coef          weight       ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String     Float64       Float64      Float64   </span>
─────┼─────────────────────────────────────────────────
   1 │ selenium   -0.000105864  0.000856712   -0.12357
   2 │ manganese  -0.00788716   0.0638276     -0.12357
   3 │ lead       -0.00914645   0.0740185     -0.12357
   4 │ copper     -0.0476113    0.385299      -0.12357
   5 │ magnesium  -0.058819     0.475999      -0.12357
Scaled effect size (positive direction)
<span class="sgr1">10×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure  coef        weight      ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String    Float64     Float64     Float64   </span>
─────┼─────────────────────────────────────────────
   1 │ zinc      0.00271249  0.00695574   0.389964
   2 │ cadmium   0.00517726  0.0132763    0.389964
   3 │ chromium  0.00802308  0.0205739    0.389964
   4 │ sodium    0.00843016  0.0216178    0.389964
   5 │ mercury   0.0095572   0.0245079    0.389964
   6 │ arsenic   0.013444    0.0344749    0.389964
   7 │ silver    0.0136815   0.0350839    0.389964
   8 │ barium    0.0231929   0.0594745    0.389964
   9 │ iron      0.0241278   0.061872     0.389964
  10 │ calcium   0.281618    0.722163     0.389964
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.35667    0.107878   -3.31    0.0009  -0.568107  -0.145233
mixture       0.266394   0.0710247   3.75    0.0002   0.127188   0.4056
─────────────────────────────────────────────────────────────────────────
</code></pre><p>First note that qgcomp can be very fast relative to competing methods (with their example times given from single runs from a laptop). </p><p>One advantage of quantile g-computation over other methods that estimate  &quot;mixture effects&quot; (the effect of changing all exposures at once), is that it  is very computationally efficient. Contrasting methods such as WQS (<code>gWQS</code>  package) and Bayesian Kernel Machine regression (<code>bkmr</code> package),  quantile g-computation can provide results many orders of magnitude faster. For example, the example above ran 3000X faster for quantile g-computation versus WQS regression, and we estimate the speedup would be several hundred thousand times versus Bayesian kernel machine regression. </p><p>The speed relies on an efficient method to fit qgcomp when exposures are added additively to the model. When exposures are added using non-linear terms or non-additive terms (see below for examples), then qgcomp will be slower but often still faster than competetive approaches.</p><p>Quantile g-computation yields fixed weights in the estimation procedure, similar to WQS regression. However, note that the weights from <code>qgcomp_glm_noboot</code>  can be negative or positive. When all effects are linear and in the same  direction (&quot;directional homogeneity&quot;), quantile g-computation is equivalent to  weighted quantile sum regression in large samples.</p><p>The overall mixture effect from quantile g-computation (<span>$\psi$</span>1) is interpreted as  the effect on the outcome of increasing every exposure by one quantile, possibly conditional on covariates. Given the overall exposure effect, the weights are considered fixed and so do not have confidence intervals or p-values.</p><pre><code class="language-julia hljs">qc_fit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled effect size (negative direction)
<span class="sgr1">5×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure   coef          weight       ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String     Float64       Float64      Float64   </span>
─────┼─────────────────────────────────────────────────
   1 │ selenium   -0.000105864  0.000856712   -0.12357
   2 │ manganese  -0.00788716   0.0638276     -0.12357
   3 │ lead       -0.00914645   0.0740185     -0.12357
   4 │ copper     -0.0476113    0.385299      -0.12357
   5 │ magnesium  -0.058819     0.475999      -0.12357
Scaled effect size (positive direction)
<span class="sgr1">10×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure  coef        weight      ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String    Float64     Float64     Float64   </span>
─────┼─────────────────────────────────────────────
   1 │ zinc      0.00271249  0.00695574   0.389964
   2 │ cadmium   0.00517726  0.0132763    0.389964
   3 │ chromium  0.00802308  0.0205739    0.389964
   4 │ sodium    0.00843016  0.0216178    0.389964
   5 │ mercury   0.0095572   0.0245079    0.389964
   6 │ arsenic   0.013444    0.0344749    0.389964
   7 │ silver    0.0136815   0.0350839    0.389964
   8 │ barium    0.0231929   0.0594745    0.389964
   9 │ iron      0.0241278   0.061872     0.389964
  10 │ calcium   0.281618    0.722163     0.389964
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.35667    0.107878   -3.31    0.0009  -0.568107  -0.145233
mixture       0.266394   0.0710247   3.75    0.0002   0.127188   0.4056
─────────────────────────────────────────────────────────────────────────
</code></pre><p>Now let&quot;s take a brief look under the hood. <code>qgcomp</code> works in steps. First, the exposure variables are &quot;quantized&quot; or turned into score variables based on the total number of quantiles from the parameter <code>q</code>. You can access these via the <code>qx</code> object from the <code>qgcomp</code> fit object.</p><pre><code class="language-julia hljs"># quantized data
println(qc_fit.data[1:10,:])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr1">10×16 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> arsenic  barium   cadmium  calcium  chromium  copper   iron     lead     magnesium  manganese  mercury  selenium  silver   sodium   zinc     y          </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64  Float64  Float64  Float64   Float64  Float64  Float64  Float64    Float64    Float64  Float64   Float64  Float64  Float64  Float64    </span>
─────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │     2.0      2.0      3.0      0.0       1.0      3.0      3.0      3.0        1.0        3.0      0.0       2.0      0.0      0.0      3.0  -0.600799
   2 │     2.0      2.0      0.0      0.0       2.0      2.0      1.0      2.0        2.0        0.0      1.0       3.0      1.0      3.0      0.0  -0.20223
   3 │     2.0      2.0      3.0      1.0       3.0      3.0      1.0      1.0        3.0        1.0      2.0       2.0      1.0      3.0      0.0  -1.21641
   4 │     1.0      0.0      0.0      3.0       1.0      3.0      0.0      2.0        3.0        1.0      2.0       2.0      3.0      3.0      3.0   0.182631
   5 │     2.0      3.0      2.0      3.0       0.0      1.0      2.0      2.0        1.0        3.0      3.0       1.0      0.0      0.0      0.0   1.17605
   6 │     3.0      2.0      0.0      0.0       0.0      2.0      1.0      1.0        0.0        1.0      2.0       0.0      3.0      3.0      2.0  -0.410091
   7 │     1.0      3.0      2.0      2.0       0.0      3.0      2.0      1.0        3.0        1.0      0.0       1.0      2.0      2.0      3.0  -0.592918
   8 │     2.0      0.0      1.0      2.0       2.0      3.0      0.0      1.0        2.0        0.0      2.0       0.0      0.0      0.0      3.0   0.0405167
   9 │     2.0      1.0      3.0      1.0       2.0      2.0      2.0      3.0        2.0        2.0      0.0       3.0      2.0      2.0      1.0  -0.472098
  10 │     2.0      0.0      0.0      3.0       1.0      1.0      3.0      2.0        3.0        3.0      3.0       0.0      2.0      3.0      3.0   0.434029</code></pre><p>You can re-fit a linear model using these quantized exposures. This is the &quot;underlying model&quot; of a qgcomp fit.</p><pre><code class="language-julia hljs"># regression with quantized data
newfit = lm(@formula(y ~ arsenic + barium + cadmium + calcium + chromium + copper +
    iron + lead + magnesium + manganese + mercury + selenium +
    silver + sodium + zinc), qc_fit.data)
println(newfit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StatsModels.TableRegressionModel{GLM.LinearModel{GLM.LmResp{Vector{Float64}}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}

y ~ 1 + arsenic + barium + cadmium + calcium + chromium + copper + iron + lead + magnesium + manganese + mercury + selenium + silver + sodium + zinc

Coefficients:
──────────────────────────────────────────────────────────────────────────────
                    Coef.  Std. Error      t  Pr(&gt;|t|)   Lower 95%   Upper 95%
──────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.35667       0.107878   -3.31    0.0010  -0.568696   -0.144644
arsenic       0.013444      0.0184371   0.73    0.4663  -0.0227926   0.0496805
barium        0.0231929     0.0183474   1.26    0.2069  -0.0128675   0.0592533
cadmium       0.00517726    0.0181048   0.29    0.7750  -0.0304063   0.0407608
calcium       0.281618      0.0221639  12.71    &lt;1e-30   0.238056    0.325179
chromium      0.00802308    0.0183908   0.44    0.6629  -0.0281225   0.0441687
copper       -0.0476113     0.0184657  -2.58    0.0103  -0.0839042  -0.0113184
iron          0.0241278     0.0201366   1.20    0.2315  -0.015449    0.0637047
lead         -0.00914645    0.0183426  -0.50    0.6183  -0.0451973   0.0269044
magnesium    -0.058819      0.0195185  -3.01    0.0027  -0.0971811  -0.0204569
manganese    -0.00788716    0.0210958  -0.37    0.7087  -0.0493493   0.033575
mercury       0.0095572     0.018297    0.52    0.6017  -0.0264041   0.0455185
selenium     -0.000105864   0.0183615  -0.01    0.9954  -0.036194    0.0359823
silver        0.0136815     0.0183149   0.75    0.4555  -0.022315    0.049678
sodium        0.00843016    0.0194193   0.43    0.6644  -0.0297368   0.0465971
zinc          0.00271249    0.0188122   0.14    0.8854  -0.0342614   0.0396864
──────────────────────────────────────────────────────────────────────────────</code></pre><p>Here you can see that, <em>for a GLM in which all quantized exposures enter linearly and additively into the underlying model</em>, the overall effect from <code>qgcomp</code> is simply the sum of the adjusted coefficients from the underlying model. </p><pre><code class="language-julia hljs">println(sum(coef(newfit)[2:end])) # sum of all coefficients excluding intercept and confounders, if any
println(qc_fit.fit[1][2])   # overall effect and intercept from qgcomp fit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.2663941776757069
0.2663941776757085</code></pre><p>This equality is why we can fit qgcomp so efficiently under such a model. This is a specific case, and <code>qgcomp</code> also allows deviations from linear/additive approaches via Monte-Carlo (here generally referred to as bootstrapping methods) and estimating-equation-based methods, which require a 2-stage approach. <code>qgcomp</code> can allow for non-linearity and non-additivity in the underlying model, as well as non-linearity in the overall model. These extensions are described in some of the following examples.</p><h3 id="Example-2:-conditional-odds-ratio,-marginal-odds-ratio-in-a-logistic-modela-name&quot;ex-logistic&quot;/a"><a class="docs-heading-anchor" href="#Example-2:-conditional-odds-ratio,-marginal-odds-ratio-in-a-logistic-modela-name&quot;ex-logistic&quot;/a">Example 2: conditional odds ratio, marginal odds ratio in a logistic model&lt;a name=&quot;ex-logistic&quot;&gt;&lt;/a&gt;</a><a id="Example-2:-conditional-odds-ratio,-marginal-odds-ratio-in-a-logistic-modela-name&quot;ex-logistic&quot;/a-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-conditional-odds-ratio,-marginal-odds-ratio-in-a-logistic-modela-name&quot;ex-logistic&quot;/a" title="Permalink"></a></h3><p>This example introduces the use of a binary outcome in <code>qgcomp</code> via the  <code>qgcomp_glm_noboot</code> function, which yields a conditional odds ratio or the <code>qgcomp_glm_boot</code>, which yields a marginal odds ratio or risk/prevalence ratio. These will not equal each other when there are non-exposure covariates (e.g. confounders) included in the model because the odds ratio is not collapsible (both are still valid). Marginal parameters will yield estimates of the population average exposure effect, which is often of more interest due to better interpretability over conditional odds ratios. Further, odds ratios are not generally of interest when risk ratios can be validly estimated, so <code>qgcomp_glm_boot</code> will estimate the risk ratio by default for binary data (set rr=FALSE to allow estimation of ORs when using <code>qgcomp_glm_boot</code>).</p><pre><code class="language-julia hljs">f = @formula(disease_state~1+a+b)
ff = FormulaTerm(f.lhs, (GLM.Term.(Symbol.(Xnm))...,))

# conditional odds ratio
qc_fit2 = qgcomp_glm_noboot(ff, metals[:,vcat(Xnm, &quot;disease_state&quot;)], Xnm, 4, Binomial())
# marginal odds ratio
qcboot_fit2 = qgcomp_glm_boot(Xoshiro(122),ff, metals[:,vcat(Xnm, &quot;disease_state&quot;)], Xnm, 4, Binomial(), B=10)
# marginal risk ratio
qcboot_fit2b = qgcomp_glm_boot(Xoshiro(122),ff, metals[:,vcat(Xnm, &quot;disease_state&quot;)], Xnm, 4, Binomial(), B=10, msmlink=LogLink())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)   0.26362     0.516085    0.51    0.6095  -0.747888    1.27513
arsenic      -0.0885288   0.0882484  -1.00    0.3158  -0.261492    0.0844348
barium        0.138002    0.0881834   1.56    0.1176  -0.0348345   0.310838
cadmium      -0.0447591   0.0868225  -0.52    0.6062  -0.214928    0.12541
calcium      -0.085805    0.106409   -0.81    0.4200  -0.294363    0.122753
chromium      0.0628293   0.0881578   0.71    0.4760  -0.109957    0.235615
copper       -0.113293    0.0886233  -1.28    0.2011  -0.286991    0.0604059
iron         -0.0215195   0.0966865  -0.22    0.8239  -0.211022    0.167983
lead         -0.0299151   0.0881026  -0.34    0.7342  -0.202593    0.142763
magnesium     0.0506531   0.0937246   0.54    0.5889  -0.133044    0.23435
manganese    -0.0718927   0.10069    -0.71    0.4752  -0.269242    0.125457
mercury      -0.033734    0.0878275  -0.38    0.7009  -0.205873    0.138405
selenium     -0.206726    0.0884817  -2.34    0.0195  -0.380147   -0.0333048
silver        0.0367468   0.0879218   0.42    0.6760  -0.135577    0.20907
sodium        0.0252791   0.0928861   0.27    0.7855  -0.156774    0.207332
zinc          0.0784991   0.0900685   0.87    0.3835  -0.098032    0.25503
────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.56237     0.205017  -2.74    0.0061  -0.964197  -0.160543
mixture      -0.163725    0.138491  -1.18    0.2371  -0.435162   0.107712
─────────────────────────────────────────────────────────────────────────
</code></pre><p>Compare a <code>qgcomp_glm_noboot</code> fit:</p><pre><code class="language-julia hljs">qc_fit2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled effect size (negative direction)
<span class="sgr1">9×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure   coef        weight     ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String     Float64     Float64    Float64   </span>
─────┼─────────────────────────────────────────────
   1 │ iron       -0.0215195  0.0309112  -0.696173
   2 │ lead       -0.0299151  0.0429708  -0.696173
   3 │ mercury    -0.033734   0.0484564  -0.696173
   4 │ cadmium    -0.0447591  0.0642931  -0.696173
   5 │ manganese  -0.0718927  0.103268   -0.696173
   6 │ calcium    -0.085805   0.123252   -0.696173
   7 │ arsenic    -0.0885288  0.127165   -0.696173
   8 │ copper     -0.113293   0.162736   -0.696173
   9 │ selenium   -0.206726   0.296946   -0.696173
Scaled effect size (positive direction)
<span class="sgr1">6×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure   coef       weight     ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String     Float64    Float64    Float64   </span>
─────┼────────────────────────────────────────────
   1 │ sodium     0.0252791  0.064486    0.392009
   2 │ silver     0.0367468  0.0937398   0.392009
   3 │ magnesium  0.0506531  0.129214    0.392009
   4 │ chromium   0.0628293  0.160275    0.392009
   5 │ zinc       0.0784991  0.200248    0.392009
   6 │ barium     0.138002   0.352037    0.392009
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)   0.26362     0.516085   0.51    0.6095  -0.747888   1.27513
mixture      -0.304163    0.340134  -0.89    0.3712  -0.970813   0.362486
─────────────────────────────────────────────────────────────────────────
</code></pre><p>with a qgcomp<em>glm</em>boot fit:</p><pre><code class="language-julia hljs">qcboot_fit2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)   0.26362     0.516085    0.51    0.6095  -0.747888    1.27513
arsenic      -0.0885288   0.0882484  -1.00    0.3158  -0.261492    0.0844348
barium        0.138002    0.0881834   1.56    0.1176  -0.0348345   0.310838
cadmium      -0.0447591   0.0868225  -0.52    0.6062  -0.214928    0.12541
calcium      -0.085805    0.106409   -0.81    0.4200  -0.294363    0.122753
chromium      0.0628293   0.0881578   0.71    0.4760  -0.109957    0.235615
copper       -0.113293    0.0886233  -1.28    0.2011  -0.286991    0.0604059
iron         -0.0215195   0.0966865  -0.22    0.8239  -0.211022    0.167983
lead         -0.0299151   0.0881026  -0.34    0.7342  -0.202593    0.142763
magnesium     0.0506531   0.0937246   0.54    0.5889  -0.133044    0.23435
manganese    -0.0718927   0.10069    -0.71    0.4752  -0.269242    0.125457
mercury      -0.033734    0.0878275  -0.38    0.7009  -0.205873    0.138405
selenium     -0.206726    0.0884817  -2.34    0.0195  -0.380147   -0.0333048
silver        0.0367468   0.0879218   0.42    0.6760  -0.135577    0.20907
sodium        0.0252791   0.0928861   0.27    0.7855  -0.156774    0.207332
zinc          0.0784991   0.0900685   0.87    0.3835  -0.098032    0.25503
────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)   0.26362     0.441401   0.60    0.5504   -0.60151   1.12875
mixture      -0.304163    0.276131  -1.10    0.2707   -0.84537   0.237043
─────────────────────────────────────────────────────────────────────────
</code></pre><p>with a qgcomp<em>glm</em>boot fit, where the risk/prevalence ratio is estimated, rather than the odds ratio:</p><pre><code class="language-julia hljs">qcboot_fit2b</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)   0.26362     0.516085    0.51    0.6095  -0.747888    1.27513
arsenic      -0.0885288   0.0882484  -1.00    0.3158  -0.261492    0.0844348
barium        0.138002    0.0881834   1.56    0.1176  -0.0348345   0.310838
cadmium      -0.0447591   0.0868225  -0.52    0.6062  -0.214928    0.12541
calcium      -0.085805    0.106409   -0.81    0.4200  -0.294363    0.122753
chromium      0.0628293   0.0881578   0.71    0.4760  -0.109957    0.235615
copper       -0.113293    0.0886233  -1.28    0.2011  -0.286991    0.0604059
iron         -0.0215195   0.0966865  -0.22    0.8239  -0.211022    0.167983
lead         -0.0299151   0.0881026  -0.34    0.7342  -0.202593    0.142763
magnesium     0.0506531   0.0937246   0.54    0.5889  -0.133044    0.23435
manganese    -0.0718927   0.10069    -0.71    0.4752  -0.269242    0.125457
mercury      -0.033734    0.0878275  -0.38    0.7009  -0.205873    0.138405
selenium     -0.206726    0.0884817  -2.34    0.0195  -0.380147   -0.0333048
silver        0.0367468   0.0879218   0.42    0.6760  -0.135577    0.20907
sodium        0.0252791   0.0928861   0.27    0.7855  -0.156774    0.207332
zinc          0.0784991   0.0900685   0.87    0.3835  -0.098032    0.25503
────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.56237     0.205017  -2.74    0.0061  -0.964197  -0.160543
mixture      -0.163725    0.138491  -1.18    0.2371  -0.435162   0.107712
─────────────────────────────────────────────────────────────────────────
</code></pre><h3 id="Example-3:-adjusting-for-covariates,-plotting-estimates"><a class="docs-heading-anchor" href="#Example-3:-adjusting-for-covariates,-plotting-estimates">Example 3: adjusting for covariates, plotting estimates</a><a id="Example-3:-adjusting-for-covariates,-plotting-estimates-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-adjusting-for-covariates,-plotting-estimates" title="Permalink"></a></h3><p>In the following code we run a maternal age-adjusted linear model with <code>qgcomp</code> (<code>family = Normal()</code>). Further, we plot both the weights, as well as the mixture slope which yields overall model confidence bounds, representing the bounds that, for each value of the joint exposure are expected to contain the true regression line over 95% of trials (so-called 95% &quot;pointwise&quot; bounds for the regression line). The pointwise comparison bounds, denoted by error bars on the plot, represent comparisons of the expected difference in outcomes at each quantile, with reference  to a specific quantile (which can be specified by the user, as below). These pointwise bounds are similar to the bounds created in the bkmr package when plotting the overall effect of all exposures. The pointwise bounds can be obtained via the pointwisebound.boot function. To avoid confusion between &quot;pointwise regression&quot; and &quot;pointwise comparison&quot; bounds, the pointwise regression bounds are denoted as the &quot;model confidence band&quot; in the plots, since they yield estimates of the same type of bounds as the <code>predict</code> function in R when applied to linear model fits.</p><p>Note that the underlying regression model is on the exposure quantile &quot;scores&quot;, which take on integer values 0, 1, ..., q-1. For plotting purposes (when plotting regression line results from qgcomp<em>glm</em>boot), the quantile score is translated into a quantile (range = [0-1]). This is not a perfect correspondence, because the quantile g-computation model treats the  quantile score as a continuous variable, but the each quantile category spans a range of quantiles. For visualization, we fix the ends of the plot at the mid-points of the first and last quantile cut-point, so the range of the plot will change slightly if &quot;q&quot; is changed.</p><pre><code class="language-julia hljs">using Plots
qc_fit3 = qgcomp_glm_noboot(@formula(y ~ mage35 + arsenic + barium + cadmium + calcium + chloride +
                           chromium + copper + iron + lead + magnesium + manganese +
                           mercury + selenium + silver + sodium + zinc),
                         metals, Xnm, 4, Normal())
println(qc_fit3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scaled effect size (negative direction)
<span class="sgr1">5×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure   coef          weight      ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String     Float64       Float64     Float64   </span>
─────┼────────────────────────────────────────────────
   1 │ selenium   -0.000460942  0.00371898  -0.123943
   2 │ manganese  -0.00755256   0.0609356   -0.123943
   3 │ lead       -0.0105484    0.0851069   -0.123943
   4 │ copper     -0.0439328    0.354459    -0.123943
   5 │ magnesium  -0.0614485    0.495779    -0.123943
Scaled effect size (positive direction)
<span class="sgr1">10×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> exposure  coef        weight      ψ_partial </span>
<span class="sgr1">     </span>│<span class="sgr90"> String    Float64     Float64     Float64   </span>
─────┼─────────────────────────────────────────────
   1 │ cadmium   0.00206825  0.00542973   0.380913
   2 │ sodium    0.00295159  0.00774873   0.380913
   3 │ zinc      0.00420104  0.0110289    0.380913
   4 │ chromium  0.00893029  0.0234445    0.380913
   5 │ mercury   0.0103034   0.0270493    0.380913
   6 │ arsenic   0.0107529   0.0282292    0.380913
   7 │ silver    0.0143415   0.0376503    0.380913
   8 │ iron      0.018433    0.0483918    0.380913
   9 │ barium    0.025279    0.0663644    0.380913
  10 │ calcium   0.283652    0.744663     0.380913
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.348084    0.108037   -3.22    0.0013  -0.559832   -0.136336
mixture       0.256969    0.0603624   4.26    &lt;1e-04   0.138661    0.375277
mage35        0.0346352   0.071459    0.48    0.6279  -0.105422    0.174692
chloride      0.0284367   0.0215315   1.32    0.1866  -0.0137643   0.0706378
────────────────────────────────────────────────────────────────────────────</code></pre><pre><code class="language-julia hljs">weightplot(qc_fit3)</code></pre><img src="1f18e761.svg" alt="Example block output"/><p>From the first plot we see weights from <code>qgcomp_glm_noboot</code> function, which include both positive and negative effect directions. When the weights are all on a single side of the null, these plots are easy to in interpret since the weight corresponds to the proportion of the overall effect from each exposure. WQS uses a constraint in the model to force all of the weights to be in the same direction - unfortunately such constraints lead to biased effect estimates. The <code>qgcomp</code> package takes a different approach and allows that &quot;weights&quot; might go in either direction, indicating that some exposures may beneficial, and some harmful, or there may be sampling variation due to using small or moderate sample sizes (or, more often, systematic bias such as unmeasured confounding). The &quot;weights&quot; in <code>qgcomp</code> correspond to the proportion of the overall effect when all of the exposures have effects in the same direction, but otherwise they correspond to the proportion of the effect <em>in a particular direction</em>, which may be small (or large) compared to the overall &quot;mixture&quot; effect. NOTE: the left and right sides of the  plot should not be compared with each other because the  length of the bars corresponds to the effect size only relative to other effects in the same direction. The darkness of the bars corresponds to the overall effect size - in this case the bars on the right (positive) side of the plot are darker because the overall &quot;mixture&quot; effect is positive. Thus, the shading allows one to make informal comparisons across the left and right sides: a large, darkly shaded bar indicates a larger independent effect than a large, lightly shaded bar.</p><pre><code class="language-julia hljs">qcboot_fit3 = qgcomp_glm_boot(Xoshiro(122), @formula(y ~ mage35 + arsenic + barium + cadmium + calcium + chloride +
                           chromium + copper + iron + lead + magnesium + manganese +
                           mercury + selenium + silver + sodium + zinc), metals, Xnm, 4, Normal(),
                           B=50)# B should be 200-500+ in practice
println(qcboot_fit3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
───────────────────────────────────────────────────────────────────────────────
                    Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%    Upper 95%
───────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.348084      0.108037   -3.22    0.0013  -0.559832   -0.136336
mage35        0.0346352     0.0603624   0.57    0.5661  -0.0836729   0.152943
arsenic       0.0107529     0.0188063   0.57    0.5675  -0.0261068   0.0476125
barium        0.025279      0.0184157   1.37    0.1698  -0.0108151   0.0613732
cadmium       0.00206825    0.0188566   0.11    0.9127  -0.03489     0.0390265
calcium       0.283652      0.0222722  12.74    &lt;1e-36   0.239999    0.327304
chloride      0.0284367     0.0215315   1.32    0.1866  -0.0137643   0.0706378
chromium      0.00893029    0.0184023   0.49    0.6275  -0.0271375   0.0449981
copper       -0.0439328     0.0186386  -2.36    0.0184  -0.0804638  -0.00740184
iron          0.018433      0.0205405   0.90    0.3695  -0.0218257   0.0586918
lead         -0.0105484     0.0183997  -0.57    0.5664  -0.0466112   0.0255143
magnesium    -0.0614485     0.019601   -3.13    0.0017  -0.0998658  -0.0230312
manganese    -0.00755256    0.0211057  -0.36    0.7205  -0.048919    0.0338139
mercury       0.0103034     0.0184555   0.56    0.5767  -0.0258688   0.0464756
selenium     -0.000460942   0.0183756  -0.03    0.9800  -0.0364765   0.0355546
silver        0.0143415     0.0183184   0.78    0.4337  -0.0215619   0.0502448
sodium        0.00295159    0.019978    0.15    0.8825  -0.0362045   0.0421077
zinc          0.00420104    0.0188433   0.22    0.8236  -0.0327311   0.0411332
───────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.342787   0.119434   -2.87    0.0041  -0.576874  -0.108701
mixture       0.256969   0.0782475   3.28    0.0010   0.103607   0.410332
─────────────────────────────────────────────────────────────────────────</code></pre><pre><code class="language-julia hljs">qcee_fit3 = qgcomp_glm_ee(@formula(y ~ mage35 + arsenic + barium + cadmium + calcium + chloride +
                           chromium + copper + iron + lead + magnesium + manganese +
                           mercury + selenium + silver + sodium + zinc), metals, Xnm, 4, Normal())
println(qcee_fit3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (estimating equation based CI)
────────────────────────────────────────────────────────────────────────────────
                    Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%    Upper 95%
────────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.348084      0.101578   -3.43    0.0006  -0.547173    -0.148995
mage35        0.0346352     0.0580126   0.60    0.5505  -0.0790675    0.148338
arsenic       0.0107529     0.0180889   0.59    0.5522  -0.0247006    0.0462063
barium        0.025279      0.0175226   1.44    0.1491  -0.00906456   0.0596227
cadmium       0.00206825    0.0186968   0.11    0.9119  -0.0345768    0.0387133
calcium       0.283652      0.0198227  14.31    &lt;1e-45   0.2448       0.322503
chloride      0.0284367     0.0212988   1.34    0.1818  -0.0133081    0.0701816
chromium      0.00893029    0.0181076   0.49    0.6219  -0.02656      0.0444205
copper       -0.0439328     0.0178306  -2.46    0.0137  -0.0788801   -0.00898556
iron          0.018433      0.0186486   0.99    0.3229  -0.0181176    0.0549837
lead         -0.0105484     0.0183068  -0.58    0.5645  -0.046429     0.0253322
magnesium    -0.0614485     0.0191222  -3.21    0.0013  -0.0989273   -0.0239697
manganese    -0.00755256    0.0211863  -0.36    0.7215  -0.0490769    0.0339718
mercury       0.0103034     0.017422    0.59    0.5542  -0.023843     0.0444499
selenium     -0.000460942   0.0171991  -0.03    0.9786  -0.0341706    0.0332487
silver        0.0143415     0.0175776   0.82    0.4146  -0.02011      0.0487929
sodium        0.00295159    0.0178978   0.16    0.8690  -0.0321275    0.0380307
zinc          0.00420104    0.01872     0.22    0.8224  -0.0324894    0.0408915
────────────────────────────────────────────────────────────────────────────────
Exposure specific weights not estimated in this type of model

MSM (estimating equation based CI)
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.342787   0.1014     -3.38    0.0007  -0.541528  -0.144047
mixture       0.256969   0.0677098   3.80    0.0001   0.124261   0.389678
─────────────────────────────────────────────────────────────────────────</code></pre><p>We can change the referent category for pointwise comparisons via the <code>referentindex</code> parameter:</p><pre><code class="language-julia hljs">printbounds(bounds(qcee_fit3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff      ll_diff   ul_diff   se_diff   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64   Float64   Float64   Float64   </span>
─────┼──────────────────────────────────────────────────────────────
   1 │     0.0  -0.342787   0.0       0.0       0.0       0.0
   2 │     1.0  -0.0858181  0.256969  0.124261  0.389678  0.0677098
   3 │     2.0   0.171151   0.513939  0.248521  0.779356  0.13542
   4 │     3.0   0.428121   0.770908  0.372782  1.16903   0.203129
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul  </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64   </span>
─────┼────────────────────────────────────────────
   1 │     0.0  -0.342787   -0.736747   0.0363915
   2 │     1.0  -0.0858181  -0.231119   0.0497588
   3 │     2.0   0.171151    0.0255317  0.330264
   4 │     3.0   0.428121    0.0201018  0.859887</code></pre><pre><code class="language-julia hljs">printbounds(bounds(qcboot_fit3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff      ll_diff   ul_diff   se_diff   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64   Float64   Float64   Float64   </span>
─────┼──────────────────────────────────────────────────────────────
   1 │     0.0  -0.342787   0.0       0.0       0.0       0.0
   2 │     1.0  -0.0858181  0.256969  0.103607  0.410332  0.0782475
   3 │     2.0   0.171151   0.513939  0.207214  0.820663  0.156495
   4 │     3.0   0.428121   0.770908  0.310821  1.231     0.234743
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64    </span>
─────┼─────────────────────────────────────────────
   1 │     0.0  -0.342787   -0.44688    -0.44688
   2 │     1.0  -0.0858181  -0.0910631  -0.0910631
   3 │     2.0   0.171151    0.264754    0.264754
   4 │     3.0   0.428121    0.620571    0.620571</code></pre><pre><code class="language-julia hljs">responseplot(qcee_fit3, referentindex = 3, plots=[&quot;pointwise&quot;, &quot;model&quot;])</code></pre><img src="f6dd0f9f.svg" alt="Example block output"/><pre><code class="language-julia hljs">responseplot(qcboot_fit3, referentindex = 3, plots=[&quot;pointwise&quot;, &quot;model&quot;])</code></pre><img src="c8cf2461.svg" alt="Example block output"/><p>Using <code>qgcomp_glm_boot</code> also allows us to assess linearity of the total exposure effect (the second plot). Similar output is available for WQS (<code>gWQS</code> package), though WQS results will generally be less interpretable when exposure effects are non-linear (see below how to do this with <code>qgcomp_glm_boot</code> and <code>qgcomp_glm_ee</code>). </p><p>The plot for the <code>qcboot_fit3</code> object (using g-computation with bootstrap variance) gives predictions at the joint intervention levels of exposure. It also displays a smoothed (graphical) fit. </p><p>Note that the uncertainty intervals given in the plot are directly accessible via the <code>pointwisebound</code> (pointwise comparison confidence intervals) and <code>modelbound</code> functions (confidence interval for the regression line):</p><pre><code class="language-julia hljs">printbounds(bounds(qcee_fit3, qcee_fit3.intvals, qcee_fit3.intvals[3]))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff       ll_diff    ul_diff    se_diff   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64    Float64    Float64    Float64   </span>
─────┼─────────────────────────────────────────────────────────────────
   1 │     0.0  -0.342787   -0.513939  -0.779356  -0.248521  0.13542
   2 │     1.0  -0.0858181  -0.256969  -0.389678  -0.124261  0.0677098
   3 │     2.0   0.171151    0.0        0.0        0.0       0.0
   4 │     3.0   0.428121    0.256969   0.124261   0.389678  0.0677098
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul  </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64   </span>
─────┼────────────────────────────────────────────
   1 │     0.0  -0.342787   -0.702389   0.0333915
   2 │     1.0  -0.0858181  -0.212363   0.0423633
   3 │     2.0   0.171151    0.022698   0.330975
   4 │     3.0   0.428121    0.0279388  0.7985</code></pre><pre><code class="language-julia hljs">printbounds(bounds(qcboot_fit3))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff      ll_diff   ul_diff   se_diff   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64   Float64   Float64   Float64   </span>
─────┼──────────────────────────────────────────────────────────────
   1 │     0.0  -0.342787   0.0       0.0       0.0       0.0
   2 │     1.0  -0.0858181  0.256969  0.103607  0.410332  0.0782475
   3 │     2.0   0.171151   0.513939  0.207214  0.820663  0.156495
   4 │     3.0   0.428121   0.770908  0.310821  1.231     0.234743
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64    </span>
─────┼─────────────────────────────────────────────
   1 │     0.0  -0.342787   -0.44688    -0.44688
   2 │     1.0  -0.0858181  -0.0910631  -0.0910631
   3 │     2.0   0.171151    0.264754    0.264754
   4 │     3.0   0.428121    0.620571    0.620571</code></pre><p>Because qgcomp estimates a joint effect of multiple exposures, we cannot, in general, assess model fit by overlaying predictions from the plots above with the data. Hence, it is useful to explore non-linearity by fitting models that allow for non-linear effects, as in the next example.</p><h3 id="Example-4:-non-linearity-(and-non-homogeneity)"><a class="docs-heading-anchor" href="#Example-4:-non-linearity-(and-non-homogeneity)">Example 4: non-linearity (and non-homogeneity)</a><a id="Example-4:-non-linearity-(and-non-homogeneity)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-non-linearity-(and-non-homogeneity)" title="Permalink"></a></h3><p><code>qgcomp</code> (specifically <code>qgcomp_*_boot</code> and <code>qgcomp_*_ee</code> methods) addresses non-linearity in a way similar to standard parametric regression models, which lends itself to being able to leverage R language features for n-lin parametric models (or, more precisely, parametric models that deviate from a purely additive, linear function on the link function basis via the use of basis function representation of non-linear functions).  Here is an example where we use a feature of the R language for fitting models with interaction terms. We use <code>y~. + .^2</code> as the model formula, which fits a model that allows for quadratic term for every predictor in the model. </p><h4 id="Aside:-some-details-on-qgcomp-methods-for-non-linearity"><a class="docs-heading-anchor" href="#Aside:-some-details-on-qgcomp-methods-for-non-linearity">Aside: some details on qgcomp methods for non-linearity</a><a id="Aside:-some-details-on-qgcomp-methods-for-non-linearity-1"></a><a class="docs-heading-anchor-permalink" href="#Aside:-some-details-on-qgcomp-methods-for-non-linearity" title="Permalink"></a></h4><p>Note that both <code>qgcomp_*_boot</code> (bootstrap) and <code>qgcomp_*_ee</code> (estimating equations) use standard methods for g-computation, whereas the <code>qgcomp_*_noboot</code> methods use a fast algorithm that works under the assumption of linearity and additivity of exposures (as described in the original paper on quantile-based g-computation). The &quot;standard&quot; method of g-computation with time-fixed exposures involves first fitting conditional models for the outcome, making predictions from those models under set exposure values, and then summarizing the predicted outcome distribution, possibly by fitting a second (marginal structural) model. <code>qgcomp_*_boot</code> follows this three-step process, while <code>qgcomp_*_ee</code> leverages estimating equations (sometimes: M-estimation) to estimate the parameters of the conditional and marginal structural model simultaneously. <code>qgcomp_*_ee</code> uses a sandwich variance estimator, which is similar to GEE (generalized estimating equation) approaches, and thus, when used correctly, can yield inference for longitudinal data in the same way that GEE does. The bootstrapping approach can also do this, but it takes longer. The extension to longitudinal data is representative of the broader concept that <code>qgcomp_*_boot</code> and <code>qgcomp_*_ee</code> can be used in a broader number of settings than <code>qgcomp_*_noboot</code> algorithms, but if one assumes linearity and additivity with no clustering of observations, and conditional parameters are of interest, then they are just a slower way to get equivalent results to <code>qgcomp_*_noboot</code>.</p><p>Below, we demonstrate a non-linear conditional fit (with a linear MSM) using the bootstrap approach. Similar approaches could be used to include interaction terms between exposures, as well as between exposures and covariates. Note this example is purposefully done incorrectly, as explained below.</p><pre><code class="language-julia hljs"># create a formula with all polynomial terms for expsosure programatically by:
# 1: outcome term
lhs = GLM.Term(:y)
# 2: main terms for all exposures
main_terms = GLM.Term.(Symbol.(Xnm))
# 3: create squared terms for all exposures via a custom function
function powerterm(x::S,power::I) where {S&lt;:AbstractString, I&lt;:Int}
    FunctionTerm(^, [Term(Symbol(x)),ConstantTerm(power)], Expr(:call, :^, Symbol(x), power))
end
squared_terms = powerterm.(Xnm, 2)

# use ... &quot;splatting&quot; to combine all terms into a tuple
rhs = (vcat(main_terms, squared_terms)...,)

ffsq = FormulaTerm(lhs, rhs) # this is a shorthand way of constructing the same object you would get from  @formula(y~ x1 + x1^2 + x2 + x2^2 + ...)


qcboot_fit4 = qgcomp_glm_boot(rng, ffsq, metals, Xnm, 4, Normal(), B=100)
println(qcboot_fit4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────────
                     Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────────
(Intercept)    -0.376056     0.136222   -2.76    0.0058  -0.643045    -0.109066
arsenic         0.030428     0.065257    0.47    0.6410  -0.0974733    0.158329
barium         -0.0198754    0.0658611  -0.30    0.7628  -0.148961     0.10921
cadmium         0.0911165    0.0640401   1.42    0.1548  -0.0343997    0.216633
calcium         0.145071     0.0855895   1.69    0.0901  -0.0226818    0.312823
chromium        0.0957044    0.0644359   1.49    0.1375  -0.0305877    0.221996
copper         -0.102326     0.065496   -1.56    0.1182  -0.230695     0.0260441
iron            0.0470454    0.0692798   0.68    0.4971  -0.0887405    0.182831
lead            0.0545809    0.0653268   0.84    0.4034  -0.0734572    0.182619
magnesium      -0.0198047    0.068335   -0.29    0.7720  -0.153739     0.114129
manganese      -0.00827842   0.0657335  -0.13    0.8998  -0.137114     0.120557
mercury        -0.0495722    0.0652753  -0.76    0.4476  -0.177509     0.0783651
selenium        0.0843153    0.064828    1.30    0.1934  -0.0427453    0.211376
silver          0.00961506   0.0651674   0.15    0.8827  -0.118111     0.137341
sodium          0.112357     0.074819    1.50    0.1332  -0.0342858    0.258999
zinc           -0.0530423    0.0646022  -0.82    0.4116  -0.17966      0.0735756
arsenic ^ 2    -0.00548169   0.0210363  -0.26    0.7944  -0.0467121    0.0357487
barium ^ 2      0.0128003    0.0211339   0.61    0.5447  -0.0286214    0.054222
cadmium ^ 2    -0.02871      0.0204728  -1.40    0.1608  -0.0688359    0.0114158
calcium ^ 2     0.0415287    0.0261331   1.59    0.1120  -0.00969135   0.0927487
chromium ^ 2   -0.0290913    0.0206698  -1.41    0.1593  -0.0696034    0.0114208
copper ^ 2      0.0190171    0.0210433   0.90    0.3661  -0.0222269    0.0602611
iron ^ 2       -0.00839646   0.0228599  -0.37    0.7134  -0.0532011    0.0364082
lead ^ 2       -0.0213287    0.0210484  -1.01    0.3109  -0.0625829    0.0199255
magnesium ^ 2  -0.0127241    0.0218525  -0.58    0.5604  -0.0555542    0.0301061
manganese ^ 2   0.001592     0.0222575   0.07    0.9430  -0.0420318    0.0452158
mercury ^ 2     0.0190848    0.0207263   0.92    0.3572  -0.0215381    0.0597077
selenium ^ 2   -0.0282434    0.0207192  -1.36    0.1728  -0.0688522    0.0123654
silver ^ 2      0.00027449   0.020829    0.01    0.9895  -0.0405497    0.0410987
sodium ^ 2     -0.0370364    0.0247802  -1.49    0.1350  -0.0856047    0.0115319
zinc ^ 2        0.0176189    0.0207208   0.85    0.3952  -0.022993     0.0582309
────────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────
                 Coef.  Std. Error      z  Pr(&gt;|z|)  Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────
(Intercept)  -0.31696    0.099879   -3.17    0.0015  -0.512719  -0.121201
mixture       0.240047   0.0655512   3.66    0.0003   0.111569   0.368525
─────────────────────────────────────────────────────────────────────────</code></pre><pre><code class="language-julia hljs">responseplot(qcboot_fit4, plots=[&quot;pointwise&quot;, &quot;model&quot;])</code></pre><img src="5b518511.svg" alt="Example block output"/><p>Note that allowing for a non-linear effect of all exposures induces an apparent non-linear trend in the overall exposure effect. The smoothed regression line is  still well within the confidence bands of the marginal linear model  (by default, the overall effect of joint exposure is assumed linear,  though this assumption can be relaxed via the &quot;degree&quot; parameter in qgcomp<em>glm</em>boot or qgcomp<em>glm</em>ee,  as follows:</p><pre><code class="language-julia hljs">qcboot_fit5 = qgcomp_glm_boot(Xoshiro(122),ffsq, metals, Xnm, 4, Normal(), msmformula = @formula(y~mixture+mixture^2)) # directly specify MSM formula
responseplot(qcboot_fit5)</code></pre><img src="8be8384d.svg" alt="Example block output"/><pre><code class="language-julia hljs">qcee_fit5b = qgcomp_glm_ee(ffsq, metals, Xnm, 4, Normal(), msmformula = @formula(y~mixture+mixture^2)) #Using estimating equations
responseplot(qcee_fit5b)</code></pre><img src="f3db4554.svg" alt="Example block output"/><p>Note that some features are not availble to <code>qgcomp_*_ee</code> methods, which use estimating equations, rather than maximum likelihood methods. Briefly, these allow assessment of uncertainty under n-lin (and other) scenarios where the <code>qgcomp_*_noboot</code> functions cannot, since they rely on the additivity and linearity assumptions to achieve speed. The <code>qgcomp_*_ee</code> methods will generally be faster than a bootstrapped version, but they are not used extensively here because they are the newest additions to the qgcomp package, and the bootstrapped versions can be made fast (but not accurate) by reducing the number of bootstraps. Where available, the <code>qgcomp_*_ee</code> will be preferred to the <code>qgcomp_*_boot</code> versions for more stable and faster analyses when bootstrapping would otherwise be necessary.</p><p>Once again, we can access numerical estimates of uncertainty (answers differ between the <code>qgcomp_*_boot</code> and <code>qgcomp_*_ee</code> fits due to the small number of bootstrap samples):</p><pre><code class="language-julia hljs"># not yet implemented
printbounds(bounds(qcboot_fit5))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff      ll_diff    ul_diff   se_diff  </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64   Float64    Float64   Float64  </span>
─────┼──────────────────────────────────────────────────────────────
   1 │     0.0  -0.376056   0.0       0.0        0.0       0.0
   2 │     1.0  -0.0178171  0.358239  0.0194254  0.697052  0.172867
   3 │     2.0   0.22223    0.598286  0.180538   1.01603   0.213141
   4 │     3.0   0.344086   0.720141  0.300055   1.14023   0.214334
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul   </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64    </span>
─────┼─────────────────────────────────────────────
   1 │     0.0  -0.376056   -0.662441   0.00779986
   2 │     1.0  -0.0178171  -0.252487   0.244904
   3 │     2.0   0.22223     0.0256724  0.461402
   4 │     3.0   0.344086   -0.0834874  0.783709</code></pre><pre><code class="language-julia hljs">printbounds(bounds(qcee_fit5b))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Pointwise bounds
<span class="sgr1">4×6 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     diff      ll_diff   ul_diff   se_diff  </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64   Float64   Float64   Float64  </span>
─────┼─────────────────────────────────────────────────────────────
   1 │     0.0  -0.376056   0.0       0.0       0.0       0.0
   2 │     1.0  -0.0178171  0.358239  0.02908   0.687397  0.167941
   3 │     2.0   0.22223    0.598286  0.192297  1.00427   0.207141
   4 │     3.0   0.344086   0.720141  0.318168  1.12211   0.205092
Modelwise bounds
<span class="sgr1">4×4 DataFrame</span>
<span class="sgr1"> Row </span>│<span class="sgr1"> mixture  linpred     ll_simul    ul_simul  </span>
<span class="sgr1">     </span>│<span class="sgr90"> Float64  Float64     Float64     Float64   </span>
─────┼────────────────────────────────────────────
   1 │     0.0  -0.376056   -0.833046   0.0964849
   2 │     1.0  -0.0178171  -0.411051   0.268126
   3 │     2.0   0.22223    -0.0650821  0.579644
   4 │     3.0   0.344086   -0.179229   0.855204</code></pre><p>Ideally, the smooth fit will look very similar to the model prediction regression  line.</p><h4 id="Interpretation-of-model-parameters"><a class="docs-heading-anchor" href="#Interpretation-of-model-parameters">Interpretation of model parameters</a><a id="Interpretation-of-model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Interpretation-of-model-parameters" title="Permalink"></a></h4><p>As the output below shows, setting &quot;degree=2&quot; yields a second parameter in the model fit (<span>$\psi_2$</span> or mixture<span>$^2$</span>). The output of qgcomp now corresponds to estimates of the marginal structural model given by </p><p class="math-container">\[\mathbb{E}\left(Y^{\mathbf{X}_q}\right) = g(\psi_0 + \psi_1 S_q + \psi_2 S_q^2)\]</p><pre><code class="language-julia hljs">println(qcboot_fit5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────────
                     Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────────
(Intercept)    -0.376056     0.136222   -2.76    0.0058  -0.643045    -0.109066
arsenic         0.030428     0.065257    0.47    0.6410  -0.0974733    0.158329
barium         -0.0198754    0.0658611  -0.30    0.7628  -0.148961     0.10921
cadmium         0.0911165    0.0640401   1.42    0.1548  -0.0343997    0.216633
calcium         0.145071     0.0855895   1.69    0.0901  -0.0226818    0.312823
chromium        0.0957044    0.0644359   1.49    0.1375  -0.0305877    0.221996
copper         -0.102326     0.065496   -1.56    0.1182  -0.230695     0.0260441
iron            0.0470454    0.0692798   0.68    0.4971  -0.0887405    0.182831
lead            0.0545809    0.0653268   0.84    0.4034  -0.0734572    0.182619
magnesium      -0.0198047    0.068335   -0.29    0.7720  -0.153739     0.114129
manganese      -0.00827842   0.0657335  -0.13    0.8998  -0.137114     0.120557
mercury        -0.0495722    0.0652753  -0.76    0.4476  -0.177509     0.0783651
selenium        0.0843153    0.064828    1.30    0.1934  -0.0427453    0.211376
silver          0.00961506   0.0651674   0.15    0.8827  -0.118111     0.137341
sodium          0.112357     0.074819    1.50    0.1332  -0.0342858    0.258999
zinc           -0.0530423    0.0646022  -0.82    0.4116  -0.17966      0.0735756
arsenic ^ 2    -0.00548169   0.0210363  -0.26    0.7944  -0.0467121    0.0357487
barium ^ 2      0.0128003    0.0211339   0.61    0.5447  -0.0286214    0.054222
cadmium ^ 2    -0.02871      0.0204728  -1.40    0.1608  -0.0688359    0.0114158
calcium ^ 2     0.0415287    0.0261331   1.59    0.1120  -0.00969135   0.0927487
chromium ^ 2   -0.0290913    0.0206698  -1.41    0.1593  -0.0696034    0.0114208
copper ^ 2      0.0190171    0.0210433   0.90    0.3661  -0.0222269    0.0602611
iron ^ 2       -0.00839646   0.0228599  -0.37    0.7134  -0.0532011    0.0364082
lead ^ 2       -0.0213287    0.0210484  -1.01    0.3109  -0.0625829    0.0199255
magnesium ^ 2  -0.0127241    0.0218525  -0.58    0.5604  -0.0555542    0.0301061
manganese ^ 2   0.001592     0.0222575   0.07    0.9430  -0.0420318    0.0452158
mercury ^ 2     0.0190848    0.0207263   0.92    0.3572  -0.0215381    0.0597077
selenium ^ 2   -0.0282434    0.0207192  -1.36    0.1728  -0.0688522    0.0123654
silver ^ 2      0.00027449   0.020829    0.01    0.9895  -0.0405497    0.0410987
sodium ^ 2     -0.0370364    0.0247802  -1.49    0.1350  -0.0856047    0.0115319
zinc ^ 2        0.0176189    0.0207208   0.85    0.3952  -0.022993     0.0582309
────────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.376056    0.133002   -2.83    0.0047  -0.636736   -0.115376
mixture       0.417334    0.246336    1.69    0.0902  -0.0654763   0.900145
mixture ^ 2  -0.0590957   0.0783354  -0.75    0.4506  -0.21263     0.0944388
────────────────────────────────────────────────────────────────────────────</code></pre><p>so that <span>$\psi_2$</span> can be interpreted similar to quadratic terms that might appear in a generalized linear model. <span>$\psi_2$</span> estimates the change in the outcome for an additional unit of squared joint exposure, over-and-above the linear effect given by <span>$\psi_1$</span>. Informally, this is a way of assessing specific types of non-linearity in the joint exposure-response curves, and there are many other (slightly incorrect but intuitively useful) ways of interpreting parameters for squared terms in regressions (beyond the scope of this document). Intuition from generalized linear models (i.e. regarding interpretation of coefficients) applies directly to the models fit by quantile g-computation.</p><h3 id="Example-5:-comparing-model-fits-and-further-exploring-non-linearity"><a class="docs-heading-anchor" href="#Example-5:-comparing-model-fits-and-further-exploring-non-linearity">Example 5: comparing model fits and further exploring non-linearity</a><a id="Example-5:-comparing-model-fits-and-further-exploring-non-linearity-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5:-comparing-model-fits-and-further-exploring-non-linearity" title="Permalink"></a></h3><p>Exploring a non-linear fit in settings with multiple exposures is challenging. One way to explore non-linearity, as demonstrated above, is to to include all 2-way interaction terms (including quadratic terms, or &quot;self-interactions&quot;). Sometimes this approach is not desired, either because the number of terms in the model can become very large, or because some sort of model selection procedure is required, which risks inducing over-fit (biased estimates and standard errors that are too small). Short of having a set of a priori non-linear terms to include, we find it best to take a default approach (e.g. taking all second order terms) that doesn&#39;t rely on statistical significance, or to simply be honest that the search for a non-linear model is exploratory and shouldn&#39;t be relied upon for robust inference. Methods such as kernel machine regression may be good alternatives, or supplementary approaches to exploring non-linearity.</p><p>NOTE: qgcomp necessarily fits a regression model with exposures that have a small number of possible values, based on the quantile chosen. By package default, this is <code>q=4</code>, but it is difficult to fully examine non-linear fits using only four points, so we recommend exploring larger values of <code>q</code>, which will change effect estimates (i.e. the model coefficient implies a smaller change in exposures, so the expected change in the outcome will also decrease).</p><p>Here, we examine a one strategy for default and exploratory approaches to mixtures that can be implemented in qgcomp using a smaller subset of exposures (iron, lead, cadmium), which we choose via the correlation matrix. High correlations between exposures may result from a common source, so small subsets of the mixture may be useful for examining hypotheses that relate to interventions on a common environmental source or set of behaviors. We can still adjust for the measured exposures, even though only 3 our exposures of interest are considered as the mixture of interest. First, we will demonstrate a linear MSM fit. Note that <code>qgcomp_glm_boot</code> must be used in order to produce the graphics below, as <code>qgcomp_glm_noboot</code> does not calculate the necessary quantities.</p><h4 id="Graphical-approach-to-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines"><a class="docs-heading-anchor" href="#Graphical-approach-to-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines">Graphical approach to explore non-linearity in a correlated subset of exposures using splines</a><a id="Graphical-approach-to-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Graphical-approach-to-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines" title="Permalink"></a></h4><pre><code class="language-julia hljs">newXnm = [:iron, :lead, :cadmium]

qc_fit6lin = qgcomp_glm_boot(Xoshiro(122),@formula(y ~ iron + lead + cadmium +
                         mage35 + arsenic + magnesium + manganese + mercury +
                         selenium + silver + sodium + zinc),
                        metals, newXnm,
                          8, Normal(), B=100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
──────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%    Upper 95%
──────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.11903      0.0656342  -1.81    0.0698  -0.24767     0.00961124
iron          0.061136     0.0109759   5.57    &lt;1e-07   0.0396237   0.0826482
lead         -0.0114455    0.0104534  -1.09    0.2736  -0.0319338   0.00904289
cadmium      -0.00834917   0.0108388  -0.77    0.4411  -0.0295929   0.0128945
mage35        0.0881685    0.072692    1.21    0.2252  -0.0543052   0.230642
arsenic       0.0241288    0.0260853   0.92    0.3550  -0.0269974   0.075255
magnesium    -0.0151559    0.0243148  -0.62    0.5331  -0.0628121   0.0325002
manganese     0.00980085   0.0249445   0.39    0.6944  -0.0390895   0.0586912
mercury       0.0101796    0.0244803   0.42    0.6775  -0.0378008   0.0581601
selenium     -0.0400341    0.0570126  -0.70    0.4826  -0.151777    0.0717086
silver        0.0258944    0.0240887   1.07    0.2824  -0.0213187   0.0731074
sodium       -0.0664921    0.0239597  -2.78    0.0055  -0.113452   -0.0195321
zinc          0.0223891    0.0238369   0.94    0.3476  -0.0243304   0.0691086
──────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
────────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.103926    0.0682166  -1.52    0.1276  -0.237628    0.0297762
mixture       0.0413413   0.0184607   2.24    0.0251   0.00515897  0.0775236
────────────────────────────────────────────────────────────────────────────
</code></pre><p>This next model will require a different way to specify the model formula to help in exploring non-linearity via splines. The <code>@formula</code> macro in Julia does not allow splines to be specified in this way. The <code>rcs</code> function uses a restricted cubic spline function that is similar to the splines used in the <code>Hmisc</code> package (in R) and <code>%DASPLINE</code> macro (in SAS). Here, we have to explicitly specify knots, though there are helper functions to calculate knots based on the same defaults as <code>Hmisc.</code></p><p>Note that thse spline bases are done on the &quot;quantized&quot; exposures (a categories).</p><pre><code class="language-julia hljs"># getting quantiles of &quot;quantized&quot; versions for knots of restricted cubic splines
knts_iron = quantile(quantize(metals.iron, 8)[1], [0.05, 0.275, 0.5, 0.725, 0.95])
knts_cadmium = quantile(quantize(metals.cadmium, 8)[1], [0.05, 0.275, 0.5, 0.725, 0.95])
#knts_lead = quantile(quantize(metals.lead, 8)[1], [0.05, 0.275, 0.5, 0.725, 0.95])
knts_lead = rsplineknots(quantize(metals.lead)[1], 5)
#equivalent: rsplineknots(quantize(metals.lead)[1], 5)

form_spline_nonlin = term(:y) ~ term(1) + rcs(:iron, knts_iron) + rcs(:cadmium, knts_cadmium) + rcs(:lead, knts_lead) + sum([term(Symbol(t)) for t in [&quot;mage35&quot;, &quot;arsenic&quot;, &quot;magnesium&quot;, &quot;manganese&quot;, &quot;mercury&quot;, &quot;selenium&quot;, &quot;silver&quot;, &quot;sodium&quot;, &quot;zinc&quot;]])



qc_fit6nonlin = qgcomp_glm_boot(Xoshiro(122),form_spline_nonlin,
                         metals, newXnm, 8, Normal(), B=100, degree=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
──────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%   Upper 95%
──────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.0861433    0.109566   -0.79    0.4317   -0.30089     0.128603
iron         -0.0287626    0.077996   -0.37    0.7123   -0.181632    0.124107
iron_sp1      0.293482     0.458694    0.64    0.5223   -0.605542    1.1925
iron_sp2     -0.972661     2.34744    -0.41    0.6786   -5.57356     3.62823
iron_sp3      0.834657     2.69686     0.31    0.7569   -4.45109     6.12041
cadmium       0.0280514    0.0732263   0.38    0.7017   -0.115469    0.171572
cadmium_sp1  -0.107269     0.390732   -0.27    0.7837   -0.87309     0.658552
cadmium_sp2   0.360414     1.57141     0.23    0.8186   -2.71949     3.44031
cadmium_sp3  -0.586329     2.34452    -0.25    0.8025   -5.1815      4.00885
lead         -0.293546     0.233143   -1.26    0.2080   -0.750497    0.163406
lead_sp1      1.71835      1.61271     1.07    0.2866   -1.44251     4.8792
lead_sp2     -9.67862     10.8226     -0.89    0.3712  -30.8904     11.5332
lead_sp3     13.1616      17.0145      0.77    0.4392  -20.1863     46.5094
mage35        0.112559     0.0742051   1.52    0.1293   -0.03288     0.257999
arsenic       0.0163609    0.0264703   0.62    0.5365   -0.0355199   0.0682418
magnesium    -0.0102893    0.0247895  -0.42    0.6781   -0.0588758   0.0382973
manganese     0.0012059    0.0257085   0.05    0.9626   -0.0491818   0.0515936
mercury       0.00514976   0.0247839   0.21    0.8354   -0.0434258   0.0537253
selenium     -0.0417504    0.0575123  -0.73    0.4679   -0.154473    0.0709717
silver        0.0236661    0.0242169   0.98    0.3284   -0.0237982   0.0711304
sodium       -0.0672674    0.0242185  -2.78    0.0055   -0.114735   -0.0198001
zinc          0.0222288    0.0241454   0.92    0.3572   -0.0250953   0.0695529
──────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.113283    0.0785798   -1.44    0.1494  -0.267297   0.0407302
mixture       0.0384772   0.0544024    0.71    0.4794  -0.0681496  0.145104
mixture ^ 2   0.00111692  0.00795303   0.14    0.8883  -0.0144707  0.0167046
────────────────────────────────────────────────────────────────────────────
</code></pre><p>We can also elaborate on this model using further spline terms by including interactions (recalling that this will lead to non-linearity in the overall effect). This model is for easy illustration only - it is likely grossly overfit, but it demonstrates different ways to allow non-linearty and non-addivity in a flexible way (here we use the estimating equation approach for illustration - it could also be a bootstrap fit)</p><pre><code class="language-julia hljs">form_spline_nonlin_nonint = term(:y) ~ term(1) + rcs(:iron, knts_iron)* rcs(:cadmium, knts_iron) + rcs(:lead, knts_lead) + sum([term(Symbol(t)) for t in [&quot;mage35&quot;, &quot;arsenic&quot;, &quot;magnesium&quot;, &quot;manganese&quot;, &quot;mercury&quot;, &quot;selenium&quot;, &quot;silver&quot;, &quot;sodium&quot;, &quot;zinc&quot;]])

qc_fit6nonlin_nonint = qgcomp_glm_ee(form_spline_nonlin_nonint,
                         metals, newXnm, 8, Normal(), degree=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (estimating equation based CI)
───────────────────────────────────────────────────────────────────────────────────────────────
                                Coef.   Std. Error      z  Pr(&gt;|z|)      Lower 95%    Upper 95%
───────────────────────────────────────────────────────────────────────────────────────────────
(Intercept)                0.0907497     0.118834    0.76    0.4451    -0.142161      0.32366
iron                      -0.188938      0.195795   -0.96    0.3346    -0.57269       0.194814
iron_sp1                   1.78659       1.29189     1.38    0.1667    -0.745476      4.31865
iron_sp2                 -11.7289        6.9127     -1.70    0.0897   -25.2776        1.81971
iron_sp3                  15.5902        8.13052     1.92    0.0552    -0.345274     31.5258
cadmium                   -0.13909       0.141939   -0.98    0.3271    -0.417286      0.139105
cadmium_sp1                0.354809      0.918331    0.39    0.6992    -1.44509       2.1547
cadmium_sp2               -0.358119      5.06041    -0.07    0.9436   -10.2763        9.5601
cadmium_sp3               -0.796804      6.12939    -0.13    0.8966   -12.8102       11.2166
lead                      -0.233835      0.227841   -1.03    0.3047    -0.680394      0.212725
lead_sp1                   1.23397       1.52498     0.81    0.4184    -1.75493       4.22287
lead_sp2                  -6.37224      10.1314     -0.63    0.5294   -26.2295       13.485
lead_sp3                   7.96074      15.8535      0.50    0.6156   -23.1115       39.033
mage35                     0.103994      0.0693725   1.50    0.1339    -0.031974      0.239961
arsenic                    0.0115827     0.0289682   0.40    0.6893    -0.045194      0.0683594
magnesium                 -0.0055047     0.0221326  -0.25    0.8036    -0.0488839     0.0378745
manganese                  0.0130485     0.0186378   0.70    0.4839    -0.0234809     0.0495779
mercury                    0.00574976    0.0238349   0.24    0.8094    -0.0409658     0.0524653
selenium                  -0.00808939    0.0550671  -0.15    0.8832    -0.116019      0.0998401
silver                     0.0130614     0.0234118   0.56    0.5769    -0.0328249     0.0589476
sodium                    -0.0601116     0.02177    -2.76    0.0058    -0.10278      -0.0174432
zinc                       0.0235399     0.0160831   1.46    0.1433    -0.00798236    0.0550621
iron &amp; cadmium             0.124515      0.220537    0.56    0.5723    -0.30773       0.55676
iron_sp1 &amp; cadmium        -1.6152        1.41286    -1.14    0.2529    -4.38436       1.15396
iron_sp2 &amp; cadmium        12.9075        7.44396     1.73    0.0829    -1.68244      27.4974
iron_sp3 &amp; cadmium       -18.3592        8.69873    -2.11    0.0348   -35.4084       -1.31002
iron &amp; cadmium_sp1        -0.201854      1.2809     -0.16    0.8748    -2.71237       2.30866
iron_sp1 &amp; cadmium_sp1     6.40557       8.05442     0.80    0.4264    -9.3808       22.1919
iron_sp2 &amp; cadmium_sp1   -57.2364       42.8057     -1.34    0.1812  -141.134        26.6612
iron_sp3 &amp; cadmium_sp1    83.7016       50.7612      1.65    0.0992   -15.7885      183.192
iron &amp; cadmium_sp2        -0.50611       6.65489    -0.08    0.9394   -13.5494       12.5372
iron_sp1 &amp; cadmium_sp2   -20.2125       41.3549     -0.49    0.6250  -101.267        60.8416
iron_sp2 &amp; cadmium_sp2   203.944       220.431       0.93    0.3549  -228.092       635.981
iron_sp3 &amp; cadmium_sp2  -305.22        262.742      -1.16    0.2454  -820.184       209.745
iron &amp; cadmium_sp3         1.77155       7.81415     0.23    0.8206   -13.5439       17.087
iron_sp1 &amp; cadmium_sp3    11.0753       48.1014      0.23    0.8179   -83.2016      105.352
iron_sp2 &amp; cadmium_sp3  -143.111       255.397      -0.56    0.5752  -643.679       357.457
iron_sp3 &amp; cadmium_sp3   222.369       303.728       0.73    0.4641  -372.927       817.664
───────────────────────────────────────────────────────────────────────────────────────────────
Exposure specific weights not estimated in this type of model

MSM (estimating equation based CI)
────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%  Upper 95%
────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.0192986    0.103734   -0.19    0.8524  -0.222614   0.184017
mixture      -0.00458268   0.0769201  -0.06    0.9525  -0.155343   0.146178
mixture ^ 2   0.00469101   0.0111432   0.42    0.6738  -0.0171493  0.0265313
────────────────────────────────────────────────────────────────────────────
</code></pre><p>It helps to place the plots on a common y-axis, which is easy due to dependence of the qgcomp plotting functions on ggplot. Here are the two fits :</p><pre><code class="language-julia hljs">p = plot( ylim=(-0.75, .75));
responseplot!(p, qc_fit6lin, referentindex = 4, plots=[&quot;model&quot;]);
responseplot!(p, qc_fit6nonlin, referentindex = 4, plots=[&quot;model&quot;])</code></pre><img src="84c3f6ba.svg" alt="Example block output"/><p>Here&#39;s the fit with interactions :</p><pre><code class="language-julia hljs">p = plot( ylim=(-0.75, .75));
responseplot!(p, qc_fit6nonlin_nonint, referentindex = 4)</code></pre><img src="84f17f86.svg" alt="Example block output"/><h4 id="Caution-about-graphical-approaches"><a class="docs-heading-anchor" href="#Caution-about-graphical-approaches">Caution about graphical approaches</a><a id="Caution-about-graphical-approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Caution-about-graphical-approaches" title="Permalink"></a></h4><p>The underlying conditional model fit can be made extremely flexible, and the graphical representation of this (via the  smooth conditional fit) can look extremely flexible. Simply matching the overall (MSM) fit to this line is not a viable strategy for identifying parsimonious models because that would ignore potential for overfit. Thus, caution should be used when judging the accuracy of a fit when comparing the &quot;smooth conditional fit&quot; to the  &quot;MSM fit.&quot; </p><pre><code class="language-julia hljs">form_spline_overfit = term(:y) ~ term(1) +
rcs(:iron, rsplineknots(quantize(metals.iron)[1], 5))+
 rcs(:cadmium, rsplineknots(quantize(metals.cadmium)[1], 5)) +
 rcs(:lead, rsplineknots(quantize(metals.lead)[1], 5)) +
 rcs(:arsenic, rsplineknots(quantize(metals.arsenic)[1], 5)) +
 rcs(:magnesium, rsplineknots(quantize(metals.magnesium)[1], 5)) +
 rcs(:manganese, rsplineknots(quantize(metals.manganese)[1], 5)) +
 rcs(:mercury, rsplineknots(quantize(metals.mercury)[1], 5)) +
 rcs(:selenium, rsplineknots(quantize(metals.selenium)[1], 5)) +
 rcs(:sodium, rsplineknots(quantize(metals.sodium)[1], 5)) +
 rcs(:selenium, rsplineknots(quantize(metals.selenium)[1], 5)) +
 rcs(:zinc, rsplineknots(quantize(metals.zinc)[1], 5)) +
 term(:mage35)


qc_overfit = qgcomp_glm_boot(Xoshiro(122),form_spline_overfit,
                         metals, newXnm, 8, Normal(), B=100, degree=2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
────────────────────────────────────────────────────────────────────────────────────
                     Coef.   Std. Error       z  Pr(&gt;|z|)     Lower 95%    Upper 95%
────────────────────────────────────────────────────────────────────────────────────
(Intercept)     -0.0411005    0.135123    -0.30    0.7610    -0.305937     0.223736
iron             0.0423286    0.135765     0.31    0.7552    -0.223765     0.308422
iron_sp1        -0.163328     0.383567    -0.43    0.6702    -0.915106     0.58845
iron_sp2         0.522299     0.975035     0.54    0.5922    -1.38873      2.43333
iron_sp3         0.0        NaN          NaN       NaN      NaN          NaN
cadmium          0.126016     0.2319       0.54    0.5869    -0.3285       0.580531
cadmium_sp1     -0.722008     1.60841     -0.45    0.6535    -3.87443      2.43042
cadmium_sp2      4.52526     10.8416       0.42    0.6764   -16.7239      25.7744
cadmium_sp3     -6.89333     17.0978      -0.40    0.6868   -40.4045      26.6178
lead            -0.351185     0.23483     -1.50    0.1348    -0.811444     0.109073
lead_sp1         2.22142      1.63042      1.36    0.1730    -0.974138     5.41697
lead_sp2       -13.1731      10.959       -1.20    0.2293   -34.6524       8.30613
lead_sp3        18.6889      17.2407       1.08    0.2784   -15.1023      52.4802
arsenic          0.0250096    0.0561665    0.45    0.6561    -0.0850748    0.135094
arsenic_sp1      0.219466     1.39502      0.16    0.8750    -2.51473      2.95366
arsenic_sp2     -3.37086     19.996       -0.17    0.8661   -42.5623      35.8205
arsenic_sp3      7.30234     44.335        0.16    0.8692   -79.5927      94.1974
magnesium        0.0136978    0.0543133    0.25    0.8009    -0.0927543    0.12015
magnesium_sp1   -0.379678     0.361599    -1.05    0.2937    -1.0884       0.329042
magnesium_sp2    0.0        NaN          NaN       NaN      NaN          NaN
magnesium_sp3    1.18824      1.0932       1.09    0.2771    -0.954384     3.33086
manganese        0.380076     0.134748     2.82    0.0048     0.115975     0.644178
manganese_sp1   -3.14955      1.55545     -2.02    0.0429    -6.19818     -0.100925
manganese_sp2   22.1215      12.4594       1.78    0.0758    -2.29848     46.5414
manganese_sp3  -35.448       21.4907      -1.65    0.0991   -77.569        6.67298
mercury         -0.0274236    0.0430913   -0.64    0.5245    -0.111881     0.0570338
mercury_sp1      0.361694     0.612518     0.59    0.5549    -0.838819     1.56221
mercury_sp2     -0.276998    10.9003      -0.03    0.9797   -21.6413      21.0873
mercury_sp3    -52.3653     126.137       -0.42    0.6780  -299.589      194.858
selenium        -0.0412294    0.0823075   -0.50    0.6164    -0.202549     0.12009
selenium_sp1     1.76475      4.4878       0.39    0.6941    -7.03119     10.5607
selenium_sp2     0.0        NaN          NaN       NaN      NaN          NaN
selenium_sp3    -9.64721     20.0043      -0.48    0.6296   -48.8549      29.5605
sodium          -0.246027     0.118282    -2.08    0.0375    -0.477855    -0.0141997
sodium_sp1       0.497343     1.02485      0.49    0.6275    -1.51132      2.50601
sodium_sp2       0.310503     8.20162      0.04    0.9698   -15.7644      16.3854
sodium_sp3      -3.91573     14.9009      -0.26    0.7927   -33.1209      25.2895
selenium         0.0        NaN          NaN       NaN      NaN          NaN
selenium_sp1     0.0        NaN          NaN       NaN      NaN          NaN
selenium_sp2     0.0        NaN          NaN       NaN      NaN          NaN
selenium_sp3     0.0        NaN          NaN       NaN      NaN          NaN
zinc            -0.0646064    0.250267    -0.26    0.7963    -0.555121     0.425908
zinc_sp1        -0.239021     1.00116     -0.24    0.8113    -2.20126      1.72321
zinc_sp2         0.914431     2.69872      0.34    0.7347    -4.37496      6.20382
zinc_sp3         0.0        NaN          NaN       NaN      NaN          NaN
mage35           0.0901949    0.0747022    1.21    0.2273    -0.0562188    0.236609
────────────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────────
                    Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.0399548    0.0800376   -0.50    0.6176  -0.196826   0.116916
mixture       0.0270191    0.0576821    0.47    0.6395  -0.0860358  0.140074
mixture ^ 2  -0.000793366  0.00878392  -0.09    0.9280  -0.0180095  0.0164228
─────────────────────────────────────────────────────────────────────────────
</code></pre><pre><code class="language-julia hljs">responseplot(qc_overfit, referentindex = 5)</code></pre><img src="2297f4fa.svg" alt="Example block output"/><p>Here, there is little statistical evidence for even a linear trend, which makes the  smoothed conditional fit appear to be overfit. The smooth conditional fit can be turned off, as below.</p><pre><code class="language-julia hljs">responseplot(qc_overfit, referentindex = 5, plots=[&quot;pointwise&quot;, &quot;model&quot;])</code></pre><img src="dce6b870.svg" alt="Example block output"/><h3 id="Example-6:-miscellaneous-other-ways-to-allow-non-linearity"><a class="docs-heading-anchor" href="#Example-6:-miscellaneous-other-ways-to-allow-non-linearity">Example 6: miscellaneous other ways to allow non-linearity</a><a id="Example-6:-miscellaneous-other-ways-to-allow-non-linearity-1"></a><a class="docs-heading-anchor-permalink" href="#Example-6:-miscellaneous-other-ways-to-allow-non-linearity" title="Permalink"></a></h3><p>Note that these are included as examples of <em>how</em> to include non-linearities, and are not intended as  a demonstration of appropriate model selection. In fact, qc_fit7b is generally a bad idea in small to moderate sample sizes due to large numbers of parameters. </p><h4 id="using-indicator-terms-for-each-quantile"><a class="docs-heading-anchor" href="#using-indicator-terms-for-each-quantile">using indicator terms for each quantile</a><a id="using-indicator-terms-for-each-quantile-1"></a><a class="docs-heading-anchor-permalink" href="#using-indicator-terms-for-each-quantile" title="Permalink"></a></h4><p>The quantile scores of the exposures can be turned into indicator variables, rather than treated as a linear/continuous term. This requires using the &quot;contrasts&quot; keyword with <code>DummyCoding()</code> (similar to defining as a factor variable in R).</p><pre><code class="language-julia hljs">qc_fit7a = qgcomp_glm_boot(Xoshiro(122),@formula(y ~ iron + lead + cadmium +
                         mage35 + arsenic + magnesium + manganese + mercury +
                         selenium + silver + sodium + zinc),
                         metals, newXnm, 8,
                         Normal(), B=100,
                         msmformula = @formula(y~mixture + mixture^2),
                         contrasts = Dict(:iron =&gt; DummyCoding()))
# underlying fit
println(qc_fit7a.ulfit)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StatsModels.TableRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Vector{Float64}, Normal{Float64}, IdentityLink}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}

y ~ 1 + iron + lead + cadmium + mage35 + arsenic + magnesium + manganese + mercury + selenium + silver + sodium + zinc

Coefficients:
─────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
─────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.0529811    0.0806243  -0.66    0.5111  -0.211002    0.10504
iron: 1.0     0.0465717    0.0946691   0.49    0.6228  -0.138976    0.23212
iron: 2.0    -0.0569843    0.0958166  -0.59    0.5520  -0.244781    0.130813
iron: 3.0     0.143813     0.0955805   1.50    0.1324  -0.0435213   0.331148
iron: 4.0     0.0533191    0.0964207   0.55    0.5803  -0.135662    0.2423
iron: 5.0     0.303968     0.0974326   3.12    0.0018   0.113003    0.494932
iron: 6.0     0.24626      0.0973439   2.53    0.0114   0.0554691   0.43705
iron: 7.0     0.447046     0.097862    4.57    &lt;1e-05   0.25524     0.638852
lead         -0.00921034   0.0104667  -0.88    0.3789  -0.0297247   0.011304
cadmium      -0.010503     0.0108644  -0.97    0.3337  -0.0317969   0.0107908
mage35        0.0811147    0.0727458   1.12    0.2648  -0.0614645   0.223694
arsenic       0.0217555    0.0260585   0.83    0.4038  -0.0293182   0.0728292
magnesium    -0.0107584    0.0246989  -0.44    0.6631  -0.0591674   0.0376507
manganese     0.00441827   0.0255145   0.17    0.8625  -0.0455892   0.0544257
mercury       0.0039139    0.0244808   0.16    0.8730  -0.0440676   0.0518953
selenium     -0.0580853    0.057148   -1.02    0.3094  -0.170093    0.0539228
silver        0.0209716    0.024074    0.87    0.3837  -0.0262126   0.0681557
sodium       -0.0620863    0.0240445  -2.58    0.0098  -0.109213   -0.01496
zinc          0.0170784    0.0239238   0.71    0.4753  -0.0298114   0.0639682
─────────────────────────────────────────────────────────────────────────────</code></pre><pre><code class="language-julia hljs">responseplot(qc_fit7a)</code></pre><img src="24f39088.svg" alt="Example block output"/><h4 id="interactions-between-indicator-terms"><a class="docs-heading-anchor" href="#interactions-between-indicator-terms">interactions between indicator terms</a><a id="interactions-between-indicator-terms-1"></a><a class="docs-heading-anchor-permalink" href="#interactions-between-indicator-terms" title="Permalink"></a></h4><p>The indicator variables can be given a set of product terms.</p><pre><code class="language-julia hljs">qc_fit7b = qgcomp_glm_boot(Xoshiro(122),@formula(y ~ iron*lead + cadmium +
                         mage35 + arsenic + magnesium + manganese + mercury +
                         selenium + silver + sodium + zinc),
                         metals, newXnm, 8,
                         Normal(), B=200,
                         msmformula = @formula(y~mixture + mixture^2),
                         contrasts = Dict(
                          :iron =&gt; DummyCoding(),
                          #:lead =&gt; DummyCoding()
                          )
                          )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Underlying fit (Model-based CI)
──────────────────────────────────────────────────────────────────────────────────
                        Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%   Upper 95%
──────────────────────────────────────────────────────────────────────────────────
(Intercept)       -0.044317     0.119742   -0.37    0.7113  -0.279008    0.190374
iron: 1.0         -0.0677779    0.172513   -0.39    0.6944  -0.405897    0.270341
iron: 2.0         -0.0979828    0.176259   -0.56    0.5783  -0.443444    0.247478
iron: 3.0          0.159512     0.187103    0.85    0.3939  -0.207204    0.526228
iron: 4.0         -6.83558e-5   0.177794   -0.00    0.9997  -0.348538    0.348401
iron: 5.0          0.187668     0.166142    1.13    0.2587  -0.137966    0.513301
iron: 6.0          0.308667     0.162845    1.90    0.0580  -0.0105021   0.627837
iron: 7.0          0.557852     0.170882    3.26    0.0011   0.222929    0.892775
lead              -0.0139104    0.030755   -0.45    0.6511  -0.0741892   0.0463683
cadmium           -0.00857004   0.0110772  -0.77    0.4391  -0.0302809   0.0131408
mage35             0.0734449    0.0735961   1.00    0.3183  -0.0708008   0.217691
arsenic            0.0210758    0.0261915   0.80    0.4210  -0.0302587   0.0724103
magnesium         -0.0115834    0.0249359  -0.46    0.6423  -0.0604569   0.0372902
manganese          0.00808792   0.026201    0.31    0.7576  -0.0432652   0.059441
mercury            0.0057199    0.0248216   0.23    0.8177  -0.0429296   0.0543694
selenium          -0.0637555    0.0574697  -1.11    0.2673  -0.176394    0.0488831
silver             0.0207556    0.0242572   0.86    0.3922  -0.0267877   0.0682988
sodium            -0.0584547    0.0245255  -2.38    0.0172  -0.106524   -0.0103855
zinc               0.0154227    0.0240857   0.64    0.5220  -0.0317845   0.0626299
iron: 1.0 &amp; lead   0.0366519    0.0459872   0.80    0.4254  -0.0534813   0.126785
iron: 2.0 &amp; lead   0.0118357    0.0420999   0.28    0.7786  -0.0706785   0.0943499
iron: 3.0 &amp; lead  -0.00298205   0.0446856  -0.07    0.9468  -0.0905641   0.0846001
iron: 4.0 &amp; lead   0.0152142    0.0435494   0.35    0.7268  -0.0701411   0.100569
iron: 5.0 &amp; lead   0.0340209    0.0408946   0.83    0.4055  -0.0461311   0.114173
iron: 6.0 &amp; lead  -0.0187322    0.0406756  -0.46    0.6451  -0.0984549   0.0609906
iron: 7.0 &amp; lead  -0.033601     0.042793   -0.79    0.4323  -0.117474    0.0502718
──────────────────────────────────────────────────────────────────────────────────

MSM (Bootstrap based CI)
Exposure specific weights not estimated in this type of model
─────────────────────────────────────────────────────────────────────────────
                   Coef.  Std. Error      z  Pr(&gt;|z|)    Lower 95%  Upper 95%
─────────────────────────────────────────────────────────────────────────────
(Intercept)  -0.0778448   0.0856058   -0.91    0.3632  -0.245629    0.0899395
mixture       0.0107838   0.0356163    0.30    0.7621  -0.0590229   0.0805906
mixture ^ 2   0.00307447  0.00427635   0.72    0.4722  -0.00530703  0.011456
─────────────────────────────────────────────────────────────────────────────
</code></pre><pre><code class="language-julia hljs">responseplot(qc_fit7b, plots=[&quot;p&quot;, &quot;m&quot;])</code></pre><img src="38ceaf0d.svg" alt="Example block output"/><h4 id="breaks-at-specific-quantiles-(these-breaks-act-on-the-quantized-basis)"><a class="docs-heading-anchor" href="#breaks-at-specific-quantiles-(these-breaks-act-on-the-quantized-basis)">breaks at specific quantiles (these breaks act on the quantized basis)</a><a id="breaks-at-specific-quantiles-(these-breaks-act-on-the-quantized-basis)-1"></a><a class="docs-heading-anchor-permalink" href="#breaks-at-specific-quantiles-(these-breaks-act-on-the-quantized-basis)" title="Permalink"></a></h4><pre><code class="language-julia hljs">qc_fit7c = qgcomp_glm_boot(Xoshiro(122),@formula(y ~ (iron&gt;4)*(lead&gt;4) + cadmium +
                         mage35 + arsenic + magnesium + manganese + mercury +
                         selenium + silver + sodium + zinc),
                         metals, newXnm, 8,
                         Normal(), B=100,
                         msmformula = @formula(y~mixture + mixture^2),
)
# underlying fit
qc_fit7c.ulfit</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StatsModels.TableRegressionModel{GLM.GeneralizedLinearModel{GLM.GlmResp{Vector{Float64}, Normal{Float64}, IdentityLink}, GLM.DensePredChol{Float64, LinearAlgebra.CholeskyPivoted{Float64, Matrix{Float64}, Vector{Int64}}}}, Matrix{Float64}}

y ~ 1 + :(iron &gt; 4) + :(lead &gt; 4) + cadmium + mage35 + arsenic + magnesium + manganese + mercury + selenium + silver + sodium + zinc + :(iron &gt; 4) &amp; :(lead &gt; 4)

Coefficients:
──────────────────────────────────────────────────────────────────────────────────────
                           Coef.  Std. Error      z  Pr(&gt;|z|)   Lower 95%    Upper 95%
──────────────────────────────────────────────────────────────────────────────────────
(Intercept)          -0.0591011    0.0518238  -1.14    0.2541  -0.160674    0.0424717
iron &gt; 4              0.364994     0.0644886   5.66    &lt;1e-07   0.238599    0.491389
lead &gt; 4             -9.00407e-5   0.0618159  -0.00    0.9988  -0.121247    0.121067
cadmium              -0.00687475   0.0107834  -0.64    0.5238  -0.0280098   0.0142603
mage35                0.0761367    0.0725511   1.05    0.2940  -0.0660608   0.218334
arsenic               0.0204237    0.02578     0.79    0.4282  -0.0301042   0.0709516
magnesium            -0.00327998   0.0242751  -0.14    0.8925  -0.0508584   0.0442984
manganese             0.0105598    0.0247745   0.43    0.6699  -0.0379974   0.059117
mercury               0.0093969    0.0243506   0.39    0.6996  -0.0383294   0.0571231
selenium             -0.0433773    0.0567001  -0.77    0.4443  -0.154507    0.0677528
silver                0.0180725    0.0239111   0.76    0.4498  -0.0287925   0.0649374
sodium               -0.0553797    0.0240381  -2.30    0.0212  -0.102493   -0.00826591
zinc                  0.0234991    0.0238576   0.98    0.3246  -0.023261    0.0702591
iron &gt; 4 &amp; lead &gt; 4  -0.182884     0.102778   -1.78    0.0752  -0.384325    0.0185575
──────────────────────────────────────────────────────────────────────────────────────</code></pre><pre><code class="language-julia hljs">responseplot(qc_fit7c)</code></pre><img src="e51c8cd9.svg" alt="Example block output"/><p>Note one restriction on exploring non-linearity: while we can use flexible functions such as splines for individual exposures, the overall fit is limited via the <code>degree</code> parameter to polynomial functions (here a quadratic polynomial fits the non-linear model well, and a cubic polynomial fits the non-linear/non-homogeneous model well - though this is an informal argument and does not account for the wide confidence intervals). We note here that only 10 bootstrap iterations are used to calculate confidence intervals (to increase computational speed for the example), which is far too low.</p><h4 id="Statistical-approach-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines"><a class="docs-heading-anchor" href="#Statistical-approach-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines">Statistical approach explore non-linearity in a correlated subset of exposures using splines</a><a id="Statistical-approach-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines-1"></a><a class="docs-heading-anchor-permalink" href="#Statistical-approach-explore-non-linearity-in-a-correlated-subset-of-exposures-using-splines" title="Permalink"></a></h4><p>The graphical approaches don&#39;t give a clear picture of which model might be preferred, but we can compare the model fits using AIC, or BIC (information criterion that weigh model fit with over-parameterization). Both of these criterion suggest the linear model fits best (lowest AIC and BIC), which suggests that the apparently non-linear fits observed in the graphical approaches don&#39;t improve prediction of the health outcome, relative to the linear fit, due to the increase in variance associated with including more parameters.</p><pre><code class="language-julia hljs">println(aic(qc_fit6lin))
#aic(qc_fit6nonlin) |&gt; display
#aic(qc_fit6nonhom) |&gt; display</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">676.0430636979562</code></pre><pre><code class="language-julia hljs">println(bic(qc_fit6lin))
#bic(qc_fit6nonlin) |&gt; display
#bic(qc_fit6nonhom) |&gt; display</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">733.6346142156075</code></pre><p>More examples on advanced topics can be viewed in the other package vignette.</p><h2 id="FAQ"><a class="docs-heading-anchor" href="#FAQ">FAQ</a><a id="FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#FAQ" title="Permalink"></a></h2><h3 id="Why-don&#39;t-I-get-weights/scaled-effects-from-the-boot-or-ee-functions?-(and-other-questions-about-the-weights/scaled-effect-sizes)"><a class="docs-heading-anchor" href="#Why-don&#39;t-I-get-weights/scaled-effects-from-the-boot-or-ee-functions?-(and-other-questions-about-the-weights/scaled-effect-sizes)">Why don&#39;t I get weights/scaled effects from the <code>boot</code> or <code>ee</code> functions? (and other questions about the weights/scaled effect sizes)</a><a id="Why-don&#39;t-I-get-weights/scaled-effects-from-the-boot-or-ee-functions?-(and-other-questions-about-the-weights/scaled-effect-sizes)-1"></a><a class="docs-heading-anchor-permalink" href="#Why-don&#39;t-I-get-weights/scaled-effects-from-the-boot-or-ee-functions?-(and-other-questions-about-the-weights/scaled-effect-sizes)" title="Permalink"></a></h3><p>Users often use the <code>qgcomp_*_boot</code> or <code>qgcomp_*_ee</code> functions because they want to marginalize over confounders or fit a non-linear joint exposure function. In both cases, the overall exposure response will no longer correspond to a simple weighted average of model coefficients, so none of the <code>qgcomp_*_boot</code> or <code>qgcomp_*_ee</code> functions will calculate weights. In most use cases, the weights would vary according to which level of joint exposure you&quot;re at, so it is not a straightforward proposition to calculate them (and you may not wish to report 4 sets of weights if you use the default <code>q=4</code>). That is, the contribution of each exposure to the overall effect will change across levels of exposure if there is any non-linearity, which makes the weights not useful as simple inferential tools (and, at best, an approximation). If you wish to have an approximation, then use a &quot;noboot&quot; method and report the weights from that along with a caveat that they are not directly applicable to the results in which non-linearity/non-additivity/marginalization-over-covariates is performed (using boot methods). If you fit an otherwise linear model, you can get weights from a <code>qgcomp_*_noboot</code> which will be very close to the weights you might get from a linear model fit via <code>qgcomp_*_boot</code> functions, but be explicit that the weights come from a different model than the inference about joint exposure effects. </p><p>It should be emphasized here that the weights are not a stable or entirely useful quantity for many research goals. Qgcomp addresses the mixtures problem of variance inflation by focusing on a parameter that is less susceptible to variance inflation than independent effects (the psi parameters, or overall effects of a mixture). The weights are a form of independent effect and will always be sensitive to this issue, regardless of the statistical method that is used. Some statistical approaches to improving estimation of independent effects (e.g. setting <code>bayes=TRUE</code>, R package only) is accessible in many qgcomp functions, but these approaches universally introduce bias in exchange for reducing variance and shouldn&#39;t be used without a good understanding of what shrinkage and penalization methods actually accomplish. Principled and rigorous integration of these statistical approaches with qgcomp is in progress, but that work is inherently more bespoke and likely will not be available in this R package. The shrinkage and penalization literature is large and outside the scope of this software and documentation, so no other guidance is given here. In any case, the calculated weights are only interpretable as proportional effect sizes in a setting in which there is linearity, additivity, and collapsibility, and so the package makes no efforts to try to introduce weights into other settings in which those assumptions may not be met. Outside of those narrow settings, the weights would have a dubious interpretation and the programming underlying the qgcomp package errs on the side of preventing the reporting of results that are mutually inconsistent. If you are using the <code>boot</code> versions of a qgcomp function in a setting in which you know that the weights are valid, it is very likely that you do not actually need to be using the <code>boot</code> versions of the functions.</p><h3 id="Do-I-need-to-model-non-linearity-and-non-additivity-of-exposures?"><a class="docs-heading-anchor" href="#Do-I-need-to-model-non-linearity-and-non-additivity-of-exposures?">Do I need to model non-linearity and non-additivity of exposures?</a><a id="Do-I-need-to-model-non-linearity-and-non-additivity-of-exposures?-1"></a><a class="docs-heading-anchor-permalink" href="#Do-I-need-to-model-non-linearity-and-non-additivity-of-exposures?" title="Permalink"></a></h3><p>Maybe. The inferential object of qgcomp is the set of <span>$\psi$</span> parameters that correspond to a joint exposure response. As it turns out, with correlated exposures non-linearity can disguise itself as non-additivity (Belzak and Bauer [2019] Addictive Behaviors). If we were inferring independent effects, this distinction would be crucial, but for joint effects it may turn out that it doesn&#39;t matter much if you model non-linearity in the joint response function through non-additivity or non-linearity of individual exposures in a given study. Models fit in qgcomp still make the crucial assumption that you are able to model the joint exposure response via parametric models, so that assumption should not be forgotten in an effort to try to disentagle non-linearity (e.g. quadratic terms of exposures) from non-additivity (e.g. product terms between exposures). The important part to note about parametric modeling is that we have to explicitly tell the model to be non-linear, and no adaptation to non-linear settings will happen automatically. Exploring non-linearity is not a trivial endeavor.</p><h3 id="Do-I-have-to-use-quantiles?"><a class="docs-heading-anchor" href="#Do-I-have-to-use-quantiles?">Do I have to use quantiles?</a><a id="Do-I-have-to-use-quantiles?-1"></a><a class="docs-heading-anchor-permalink" href="#Do-I-have-to-use-quantiles?" title="Permalink"></a></h3><p>No. You can turn off &quot;quantization&quot; by setting <code>q=nothing</code> or you can supply your own categorization cutpoints via the &quot;breaks&quot; argument. It is up to the user to interpret the results if either of these options is taken. Frequently, <code>q=nothing</code> is used in concert with standardizing exposure variables by dividing them by their interquartile ranges (IQR). The joint exposure response can then be interpreted as the effect of an IQR change in all exposures. Using IQR/2 (with or without a log transformation before hand) will yield results that are most (roughly) compatible with the package defaults (<code>q=4</code>) but that does not require quantization. Quantized variables have nice properties: they prevent extrapolation and reduce influence of outliers, but the choice of how to include exposures in the model should be a deliberate and well-informed one. There are examples of setting <code>q=nothing</code> in the help files for qgcomp<em>glm</em>boot and qgcomp<em>glm</em>ee, but this approach is available for any of the qgcomp methods (and is accomplished nearly 100% outside of the package functions, aside from setting <code>q=nothing</code>).</p><h3 id="Can-I-cite-this-document?"><a class="docs-heading-anchor" href="#Can-I-cite-this-document?">Can I cite this document?</a><a id="Can-I-cite-this-document?-1"></a><a class="docs-heading-anchor-permalink" href="#Can-I-cite-this-document?" title="Permalink"></a></h3><p>Probably not in a scientific manuscript. If you find an idea here that is not published anywhere else and wish to develop it into a full manuscript, feel free! (But probably check with alex.keil@nih.gov to ask if a paper is already in development or is, perhaps, already published.)</p><h3 id="Where-else-can-I-get-help?"><a class="docs-heading-anchor" href="#Where-else-can-I-get-help?">Where else can I get help?</a><a id="Where-else-can-I-get-help?-1"></a><a class="docs-heading-anchor-permalink" href="#Where-else-can-I-get-help?" title="Permalink"></a></h3><p>The vignettes of the package and the help files of the functions give many, many examples of usage. Additionally, some edge case or interesting applicationsare available in the form of github gists at <a href="https://gist.github.com/alexpkeil1">https://gist.github.com/alexpkeil1</a>. If you come up with an interesting problem that you think could be solved in this package, but is currently not, feel free to submit an issue on the R package github page <a href="https://github.com/alexpkeil1/qgcomp/issues">https://github.com/alexpkeil1/qgcomp/issues</a> or J package github page <a href="https://github.com/alexpkeil1/Qgcomp.jl/issues">https://github.com/alexpkeil1/Qgcomp.jl/issues</a>. Several additions to the R package have already come about through that avenue (though not always quickly).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Help</a><a class="docs-footer-nextpage" href="../math/underlying_math/">Underlying math »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 3 October 2025 22:57">Friday 3 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
